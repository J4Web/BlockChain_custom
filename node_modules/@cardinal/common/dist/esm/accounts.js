import { __awaiter } from "tslib";
import * as splToken from "@solana/spl-token";
import * as web3 from "@solana/web3.js";
/**
 * Tries to get account based on function fn
 * Return null if account doesn't exist
 * @param fn
 * @returns
 */
export function tryGetAccount(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield fn();
        }
        catch (_a) {
            return null;
        }
    });
}
/**
 * Utility function to get associated token address
 * @param mint
 * @param owner
 * @param allowOwnerOffCurve
 * @returns
 */
export function findAta(mint, owner, allowOwnerOffCurve) {
    return __awaiter(this, void 0, void 0, function* () {
        return splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mint, owner, allowOwnerOffCurve);
    });
}
/**
 * Gets owner of mintId
 * @param connection
 * @param mintId
 * @returns
 */
export const getOwner = (connection, mintId) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const mint = new web3.PublicKey(mintId);
    const largestHolders = yield connection.getTokenLargestAccounts(mint);
    const certificateMintToken = new splToken.Token(connection, mint, splToken.TOKEN_PROGRAM_ID, 
    // not used
    web3.Keypair.generate());
    const largestTokenAccount = ((_a = largestHolders === null || largestHolders === void 0 ? void 0 : largestHolders.value[0]) === null || _a === void 0 ? void 0 : _a.address) &&
        (yield certificateMintToken.getAccountInfo((_b = largestHolders === null || largestHolders === void 0 ? void 0 : largestHolders.value[0]) === null || _b === void 0 ? void 0 : _b.address));
    return largestTokenAccount === null || largestTokenAccount === void 0 ? void 0 : largestTokenAccount.owner;
});
//# sourceMappingURL=accounts.js.map