import { __awaiter } from "tslib";
import { findAta } from "@cardinal/common";
import { CRANK_KEY, getRemainingAccountsForKind, TOKEN_MANAGER_ADDRESS, TokenManagerKind, TokenManagerState, } from "@cardinal/token-manager/dist/cjs/programs/tokenManager";
import { findMintCounterId, findTokenManagerAddress, } from "@cardinal/token-manager/dist/cjs/programs/tokenManager/pda";
import { MetadataProgram } from "@metaplex-foundation/mpl-token-metadata";
import { AnchorProvider, Program } from "@project-serum/anchor";
import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, } from "@solana/spl-token";
import { SystemProgram, SYSVAR_RENT_PUBKEY } from "@solana/web3.js";
import { STAKE_POOL_ADDRESS, STAKE_POOL_IDL } from ".";
import { ReceiptType } from "./constants";
import { findStakeAuthorizationId } from "./pda";
import { remainingAccountsForInitStakeEntry } from "./utils";
export const initPoolIdentifier = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.initIdentifier({
        accounts: {
            identifier: params.identifierId,
            payer: wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
    });
};
export const initStakePool = (connection, wallet, params) => {
    var _a;
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.initPool({
        overlayText: params.overlayText,
        imageUri: params.imageUri,
        requiresCollections: params.requiresCollections,
        requiresCreators: params.requiresCreators,
        requiresAuthorization: (_a = params.requiresAuthorization) !== null && _a !== void 0 ? _a : false,
        authority: params.authority,
        resetOnStake: params.resetOnStake,
        cooldownSeconds: params.cooldownSeconds,
        minStakeSeconds: params.minStakeSeconds,
    }, {
        accounts: {
            stakePool: params.stakePoolId,
            identifier: params.identifierId,
            payer: wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
    });
};
export const authorizeStakeEntry = (connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const [stakeAuthorizationId] = yield findStakeAuthorizationId(params.stakePoolId, params.originalMintId);
    return stakePoolProgram.instruction.authorizeMint(params.originalMintId, {
        accounts: {
            stakePool: params.stakePoolId,
            stakeAuthorizationRecord: stakeAuthorizationId,
            payer: wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
    });
});
export const initStakeEntry = (connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const remainingAccounts = yield remainingAccountsForInitStakeEntry(params.stakePoolId, params.originalMintId);
    return stakePoolProgram.instruction.initEntry(wallet.publicKey, {
        accounts: {
            stakeEntry: params.stakeEntryId,
            stakePool: params.stakePoolId,
            originalMint: params.originalMintId,
            originalMintMetadata: params.originalMintMetadatId,
            payer: wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
        remainingAccounts,
    });
});
export const initStakeMint = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.initStakeMint({ name: params.name, symbol: params.symbol }, {
        accounts: {
            stakeEntry: params.stakeEntryId,
            stakePool: params.stakePoolId,
            originalMint: params.originalMintId,
            originalMintMetadata: params.originalMintMetadatId,
            stakeMint: params.stakeMintId,
            stakeMintMetadata: params.stakeMintMetadataId,
            stakeEntryStakeMintTokenAccount: params.stakeEntryStakeMintTokenAccountId,
            mintManager: params.mintManagerId,
            payer: wallet.publicKey,
            rent: SYSVAR_RENT_PUBKEY,
            tokenProgram: TOKEN_PROGRAM_ID,
            tokenManagerProgram: TOKEN_MANAGER_ADDRESS,
            associatedToken: ASSOCIATED_TOKEN_PROGRAM_ID,
            tokenMetadataProgram: MetadataProgram.PUBKEY,
            systemProgram: SystemProgram.programId,
        },
    });
};
export const claimReceiptMint = (connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const [[tokenManagerId], [mintCounterId], stakeEntryReceiptMintTokenAccountId, userReceiptMintTokenAccountId, remainingAccounts,] = yield Promise.all([
        findTokenManagerAddress(params.receiptMintId),
        findMintCounterId(params.receiptMintId),
        findAta(params.receiptMintId, params.stakeEntryId, true),
        findAta(params.receiptMintId, wallet.publicKey, true),
        getRemainingAccountsForKind(params.receiptMintId, params.receiptType === ReceiptType.Original
            ? TokenManagerKind.Edition
            : TokenManagerKind.Managed),
    ]);
    return stakePoolProgram.instruction.claimReceiptMint({
        accounts: {
            stakeEntry: params.stakeEntryId,
            originalMint: params.originalMintId,
            receiptMint: params.receiptMintId,
            stakeEntryReceiptMintTokenAccount: stakeEntryReceiptMintTokenAccountId,
            user: wallet.publicKey,
            userReceiptMintTokenAccount: userReceiptMintTokenAccountId,
            mintCounter: mintCounterId,
            tokenManager: tokenManagerId,
            tokenManagerReceiptMintTokenAccount: params.tokenManagerReceiptMintTokenAccountId,
            tokenProgram: TOKEN_PROGRAM_ID,
            tokenManagerProgram: TOKEN_MANAGER_ADDRESS,
            systemProgram: SystemProgram.programId,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            rent: SYSVAR_RENT_PUBKEY,
        },
        remainingAccounts,
    });
});
export const stake = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.stake(params.amount, {
        accounts: {
            stakeEntry: params.stakeEntryId,
            stakePool: params.stakePoolId,
            stakeEntryOriginalMintTokenAccount: params.stakeEntryOriginalMintTokenAccountId,
            originalMint: params.originalMint,
            user: wallet.publicKey,
            userOriginalMintTokenAccount: params.userOriginalMintTokenAccountId,
            tokenProgram: TOKEN_PROGRAM_ID,
        },
    });
};
export const unstake = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.unstake({
        accounts: {
            stakePool: params.stakePoolId,
            stakeEntry: params.stakeEntryId,
            originalMint: params.originalMintId,
            stakeEntryOriginalMintTokenAccount: params.stakeEntryOriginalMintTokenAccount,
            user: params.user,
            userOriginalMintTokenAccount: params.userOriginalMintTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
        },
        remainingAccounts: params.remainingAccounts,
    });
};
export const updateStakePool = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.updatePool({
        overlayText: params.overlayText || "RENTED",
        imageUri: params.imageUri || "",
        requiresCollections: params.requiresCollections || null,
        requiresCreators: params.requiresCreators || null,
        requiresAuthorization: params.requiresAuthorization || false,
        authority: params.authority || null,
        resetOnStake: params.resetOnStake || false,
        cooldownSeconds: params.cooldownSeconds || null,
        minStakeSeconds: params.minStakeSeconds || null,
    }, {
        accounts: {
            stakePool: params.stakePoolId,
            payer: wallet.publicKey,
        },
    });
};
export const updateTotalStakeSeconds = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.updateTotalStakeSeconds({
        accounts: {
            stakeEntry: params.stakEntryId,
            lastStaker: params.lastStaker,
        },
    });
};
export const returnReceiptMint = (connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const [tokenManagerId] = yield findTokenManagerAddress(params.receiptMint);
    const tokenManagerTokenAccountId = yield findAta(params.receiptMint, (yield findTokenManagerAddress(params.receiptMint))[0], true);
    const userReceiptMintTokenAccount = yield findAta(params.receiptMint, wallet.publicKey, true);
    const transferAccounts = yield getRemainingAccountsForKind(params.receiptMint, params.tokenManagerKind);
    return stakePoolProgram.instruction.returnReceiptMint({
        accounts: {
            stakeEntry: params.stakeEntry,
            receiptMint: params.receiptMint,
            tokenManager: tokenManagerId,
            tokenManagerTokenAccount: tokenManagerTokenAccountId,
            userReceiptMintTokenAccount: userReceiptMintTokenAccount,
            user: wallet.publicKey,
            collector: CRANK_KEY,
            tokenProgram: TOKEN_PROGRAM_ID,
            tokenManagerProgram: TOKEN_MANAGER_ADDRESS,
            rent: SYSVAR_RENT_PUBKEY,
        },
        remainingAccounts: [
            ...(params.tokenManagerState === TokenManagerState.Claimed
                ? transferAccounts
                : []),
            ...params.returnAccounts,
        ],
    });
});
export const closeStakePool = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.closeStakePool({
        accounts: {
            stakePool: params.stakePoolId,
            authority: params.authority,
        },
    });
};
export const closeStakeEntry = (connection, wallet, params) => {
    const provider = new AnchorProvider(connection, wallet, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    return stakePoolProgram.instruction.closeStakeEntry({
        accounts: {
            stakePool: params.stakePoolId,
            stakeEntry: params.stakeEntryId,
            authority: params.authority,
        },
    });
};
//# sourceMappingURL=instruction.js.map