"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllStakeEntries = exports.getStakePoolsByAuthority = exports.getStakeAuthorizationsForPool = exports.getStakeAuthorizations = exports.getStakeAuthorization = exports.getPoolIdentifier = exports.getStakeEntries = exports.getStakeEntry = exports.getActiveStakeEntriesForPool = exports.getAllActiveStakeEntries = exports.getStakeEntriesForUser = exports.getAllStakePools = exports.getStakePools = exports.getStakePool = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const _1 = require(".");
const constants_1 = require("./constants");
const pda_1 = require("./pda");
const getStakePool = (connection, stakePoolId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const stakePoolProgram = new anchor_1.Program(_1.STAKE_POOL_IDL, _1.STAKE_POOL_ADDRESS, provider);
    const parsed = yield stakePoolProgram.account.stakePool.fetch(stakePoolId);
    return {
        parsed,
        pubkey: stakePoolId,
    };
});
exports.getStakePool = getStakePool;
const getStakePools = (connection, stakePoolIds) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const stakePoolProgram = new anchor_1.Program(_1.STAKE_POOL_IDL, _1.STAKE_POOL_ADDRESS, provider);
    const stakePools = (yield stakePoolProgram.account.stakePool.fetchMultiple(stakePoolIds));
    return stakePools.map((tm, i) => ({
        parsed: tm,
        pubkey: stakePoolIds[i],
    }));
});
exports.getStakePools = getStakePools;
const getAllStakePools = (connection) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: anchor_1.utils.bytes.bs58.encode(anchor_1.BorshAccountsCoder.accountDiscriminator("stakePool")),
                },
            },
        ],
    });
    const stakePoolDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakePoolData = coder.decode("stakePool", account.account.data);
            if (stakePoolData) {
                stakePoolDatas.push(Object.assign(Object.assign({}, account), { parsed: stakePoolData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakePoolDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getAllStakePools = getAllStakePools;
const getStakeEntriesForUser = (connection, user) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.STAKE_POOL_ADDRESS, {
        filters: [{ memcmp: { offset: constants_1.STAKER_OFFSET, bytes: user.toBase58() } }],
    });
    const stakeEntryDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
        }
        catch (e) {
            console.log(`Failed to decode token manager data`);
        }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getStakeEntriesForUser = getStakeEntriesForUser;
const getAllActiveStakeEntries = (connection) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: anchor_1.utils.bytes.bs58.encode(anchor_1.BorshAccountsCoder.accountDiscriminator("stakeEntry")),
                },
            },
        ],
    });
    const stakeEntryDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData &&
                stakeEntryData.lastStaker.toString() !== web3_js_1.PublicKey.default.toString()) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
        }
        catch (e) {
            // console.log(`Failed to decode stake entry data`);
        }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getAllActiveStakeEntries = getAllActiveStakeEntries;
const getActiveStakeEntriesForPool = (connection, stakePoolId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: { offset: constants_1.POOL_OFFSET, bytes: stakePoolId.toBase58() },
            },
        ],
    });
    const stakeEntryDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData &&
                stakeEntryData.lastStaker.toString() !== web3_js_1.PublicKey.default.toString()) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
        }
        catch (e) {
            // console.log(`Failed to decode token manager data`);
        }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getActiveStakeEntriesForPool = getActiveStakeEntriesForPool;
const getStakeEntry = (connection, stakeEntryId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const stakePoolProgram = new anchor_1.Program(_1.STAKE_POOL_IDL, _1.STAKE_POOL_ADDRESS, provider);
    const parsed = yield stakePoolProgram.account.stakeEntry.fetch(stakeEntryId);
    return {
        parsed,
        pubkey: stakeEntryId,
    };
});
exports.getStakeEntry = getStakeEntry;
const getStakeEntries = (connection, stakeEntryIds) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const stakePoolProgram = new anchor_1.Program(_1.STAKE_POOL_IDL, _1.STAKE_POOL_ADDRESS, provider);
    const stakeEntries = (yield stakePoolProgram.account.stakeEntry.fetchMultiple(stakeEntryIds));
    return stakeEntries.map((tm, i) => ({
        parsed: tm,
        pubkey: stakeEntryIds[i],
    }));
});
exports.getStakeEntries = getStakeEntries;
const getPoolIdentifier = (connection) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const stakePoolProgram = new anchor_1.Program(_1.STAKE_POOL_IDL, _1.STAKE_POOL_ADDRESS, provider);
    const [identifierId] = yield (0, pda_1.findIdentifierId)();
    const parsed = yield stakePoolProgram.account.identifier.fetch(identifierId);
    return {
        parsed,
        pubkey: identifierId,
    };
});
exports.getPoolIdentifier = getPoolIdentifier;
const getStakeAuthorization = (connection, stakeAuthorizationId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const stakePoolProgram = new anchor_1.Program(_1.STAKE_POOL_IDL, _1.STAKE_POOL_ADDRESS, provider);
    const parsed = yield stakePoolProgram.account.stakeAuthorizationRecord.fetch(stakeAuthorizationId);
    return {
        parsed,
        pubkey: stakeAuthorizationId,
    };
});
exports.getStakeAuthorization = getStakeAuthorization;
const getStakeAuthorizations = (connection, stakeAuthorizationIds) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const stakePoolProgram = new anchor_1.Program(_1.STAKE_POOL_IDL, _1.STAKE_POOL_ADDRESS, provider);
    const stakeAuthorizations = (yield stakePoolProgram.account.stakeAuthorizationRecord.fetchMultiple(stakeAuthorizationIds));
    return stakeAuthorizations.map((data, i) => ({
        parsed: data,
        pubkey: stakeAuthorizationIds[i],
    }));
});
exports.getStakeAuthorizations = getStakeAuthorizations;
const getStakeAuthorizationsForPool = (connection, poolId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: anchor_1.utils.bytes.bs58.encode(anchor_1.BorshAccountsCoder.accountDiscriminator("stakeAuthorizationRecord")),
                },
            },
            {
                memcmp: { offset: constants_1.POOL_OFFSET, bytes: poolId.toBase58() },
            },
        ],
    });
    const stakeAuthorizationDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const data = coder.decode("stakeAuthorizationRecord", account.account.data);
            stakeAuthorizationDatas.push(Object.assign(Object.assign({}, account), { parsed: data }));
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakeAuthorizationDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getStakeAuthorizationsForPool = getStakeAuthorizationsForPool;
const getStakePoolsByAuthority = (connection, user) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: anchor_1.utils.bytes.bs58.encode(anchor_1.BorshAccountsCoder.accountDiscriminator("stakePool")),
                },
            },
            {
                memcmp: {
                    offset: constants_1.AUTHORITY_OFFSET,
                    bytes: user.toBase58(),
                },
            },
        ],
    });
    const stakePoolDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakePoolData = coder.decode("stakePool", account.account.data);
            if (stakePoolData) {
                stakePoolDatas.push(Object.assign(Object.assign({}, account), { parsed: stakePoolData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakePoolDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getStakePoolsByAuthority = getStakePoolsByAuthority;
const getAllStakeEntries = (connection) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: anchor_1.utils.bytes.bs58.encode(anchor_1.BorshAccountsCoder.accountDiscriminator("stakeEntry")),
                },
            },
        ],
    });
    const stakeEntryDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getAllStakeEntries = getAllStakeEntries;
//# sourceMappingURL=accounts.js.map