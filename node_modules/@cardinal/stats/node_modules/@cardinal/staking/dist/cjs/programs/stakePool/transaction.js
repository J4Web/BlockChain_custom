"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withCloseStakeEntry = exports.withCloseStakePool = exports.withReturnReceiptMint = exports.withUpdateTotalStakeSeconds = exports.withUpdateStakePool = exports.withUnstake = exports.withStake = exports.withClaimReceiptMint = exports.withInitStakeMint = exports.withAuthorizeStakeEntry = exports.withInitStakeEntry = exports.withInitStakePool = exports.withInitPoolIdentifier = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@cardinal/common");
const programs_1 = require("@cardinal/token-manager/dist/cjs/programs");
const tokenManager_1 = require("@cardinal/token-manager/dist/cjs/programs/tokenManager");
const pda_1 = require("@cardinal/token-manager/dist/cjs/programs/tokenManager/pda");
const metaplex = tslib_1.__importStar(require("@metaplex-foundation/mpl-token-metadata"));
const anchor_1 = require("@project-serum/anchor");
const utils_1 = require("../../utils");
const accounts_1 = require("../rewardDistributor/accounts");
const pda_2 = require("../rewardDistributor/pda");
const transaction_1 = require("../rewardDistributor/transaction");
const accounts_2 = require("./accounts");
const constants_1 = require("./constants");
const instruction_1 = require("./instruction");
const pda_3 = require("./pda");
const utils_2 = require("./utils");
/**
 * Add init pool identifier instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @returns Transaction, public key for the created pool identifier
 */
const withInitPoolIdentifier = (transaction, connection, wallet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [identifierId] = yield (0, pda_3.findIdentifierId)();
    transaction.add((0, instruction_1.initPoolIdentifier)(connection, wallet, {
        identifierId: identifierId,
    }));
    return [transaction, identifierId];
});
exports.withInitPoolIdentifier = withInitPoolIdentifier;
const withInitStakePool = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [identifierId] = yield (0, pda_3.findIdentifierId)();
    const identifierData = yield (0, common_1.tryGetAccount)(() => (0, accounts_2.getPoolIdentifier)(connection));
    const identifier = (identifierData === null || identifierData === void 0 ? void 0 : identifierData.parsed.count) || new anchor_1.BN(1);
    if (!identifierData) {
        transaction.add((0, instruction_1.initPoolIdentifier)(connection, wallet, {
            identifierId: identifierId,
        }));
    }
    const [stakePoolId] = yield (0, pda_3.findStakePoolId)(identifier);
    transaction.add((0, instruction_1.initStakePool)(connection, wallet, {
        identifierId: identifierId,
        stakePoolId: stakePoolId,
        requiresCreators: params.requiresCreators || [],
        requiresCollections: params.requiresCollections || [],
        requiresAuthorization: params.requiresAuthorization,
        overlayText: params.overlayText || "",
        imageUri: params.imageUri || "",
        authority: wallet.publicKey,
        resetOnStake: params.resetOnStake || false,
        cooldownSeconds: params.cooldownSeconds || null,
        minStakeSeconds: params.minStakeSeconds || null,
    }));
    return [transaction, stakePoolId];
});
exports.withInitStakePool = withInitStakePool;
/**
 * Add init stake entry instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @param params
 * @returns Transaction, public key for the created stake entry
 */
const withInitStakeEntry = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [[stakeEntryId], originalMintMetadatId] = yield Promise.all([
        (0, utils_2.findStakeEntryIdFromMint)(connection, wallet.publicKey, params.stakePoolId, params.originalMintId),
        metaplex.Metadata.getPDA(params.originalMintId),
    ]);
    transaction.add(yield (0, instruction_1.initStakeEntry)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        stakeEntryId: stakeEntryId,
        originalMintId: params.originalMintId,
        originalMintMetadatId: originalMintMetadatId,
    }));
    return [transaction, stakeEntryId];
});
exports.withInitStakeEntry = withInitStakeEntry;
/**
 * Add authorize stake entry instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @param params
 * @returns Transaction
 */
const withAuthorizeStakeEntry = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    transaction.add(yield (0, instruction_1.authorizeStakeEntry)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        originalMintId: params.originalMintId,
    }));
    return transaction;
});
exports.withAuthorizeStakeEntry = withAuthorizeStakeEntry;
/**
 * Add init stake mint instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @param params
 * @returns Transaction, keypair of the created stake mint
 */
const withInitStakeMint = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [[mintManagerId], originalMintMetadataId, stakeMintMetadataId] = yield Promise.all([
        (0, pda_1.findMintManagerId)(params.stakeMintKeypair.publicKey),
        metaplex.Metadata.getPDA(params.originalMintId),
        metaplex.Metadata.getPDA(params.stakeMintKeypair.publicKey),
    ]);
    const stakeEntryStakeMintTokenAccountId = yield (0, common_1.findAta)(params.stakeMintKeypair.publicKey, params.stakeEntryId, true);
    transaction.add((0, instruction_1.initStakeMint)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        stakeEntryId: params.stakeEntryId,
        originalMintId: params.originalMintId,
        originalMintMetadatId: originalMintMetadataId,
        stakeEntryStakeMintTokenAccountId: stakeEntryStakeMintTokenAccountId,
        stakeMintId: params.stakeMintKeypair.publicKey,
        stakeMintMetadataId: stakeMintMetadataId,
        mintManagerId: mintManagerId,
        name: params.name,
        symbol: params.symbol,
    }));
    return [transaction, params.stakeMintKeypair];
});
exports.withInitStakeMint = withInitStakeMint;
/**
 * Add claim receipt mint instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @param params
 * @returns Transaction
 */
const withClaimReceiptMint = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (params.receiptType === constants_1.ReceiptType.Original &&
        (yield (0, utils_1.getMintSupply)(connection, params.receiptMintId)).gt(new anchor_1.BN(1))) {
        throw new Error("Fungible staking and locked reecipt type not supported yet");
    }
    const tokenManagerReceiptMintTokenAccountId = yield (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, connection, params.receiptMintId, (yield (0, pda_1.findTokenManagerAddress)(params.receiptMintId))[0], wallet.publicKey, true);
    transaction.add(yield (0, instruction_1.claimReceiptMint)(connection, wallet, {
        stakeEntryId: params.stakeEntryId,
        tokenManagerReceiptMintTokenAccountId: tokenManagerReceiptMintTokenAccountId,
        originalMintId: params.originalMintId,
        receiptMintId: params.receiptMintId,
        receiptType: params.receiptType,
    }));
    return transaction;
});
exports.withClaimReceiptMint = withClaimReceiptMint;
/**
 * Add stake instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @param params
 * @returns Transaction
 */
const withStake = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [stakeEntryId] = yield (0, utils_2.findStakeEntryIdFromMint)(connection, wallet.publicKey, params.stakePoolId, params.originalMintId);
    const stakeEntryOriginalMintTokenAccountId = yield (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, connection, params.originalMintId, stakeEntryId, wallet.publicKey, true);
    transaction.add((0, instruction_1.stake)(connection, wallet, {
        stakeEntryId: stakeEntryId,
        stakePoolId: params.stakePoolId,
        originalMint: params.originalMintId,
        stakeEntryOriginalMintTokenAccountId: stakeEntryOriginalMintTokenAccountId,
        userOriginalMintTokenAccountId: params.userOriginalMintTokenAccountId,
        amount: params.amount || new anchor_1.BN(1),
    }));
    return transaction;
});
exports.withStake = withStake;
/**
 * Add unstake instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @param params
 * @returns Transaction
 */
const withUnstake = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [[stakeEntryId], [rewardDistributorId]] = yield Promise.all([
        (0, utils_2.findStakeEntryIdFromMint)(connection, wallet.publicKey, params.stakePoolId, params.originalMintId),
        yield (0, pda_2.findRewardDistributorId)(params.stakePoolId),
    ]);
    const [stakeEntryData, rewardDistributorData] = yield Promise.all([
        (0, common_1.tryGetAccount)(() => (0, accounts_2.getStakeEntry)(connection, stakeEntryId)),
        (0, common_1.tryGetAccount)(() => (0, accounts_1.getRewardDistributor)(connection, rewardDistributorId)),
    ]);
    const stakePoolData = yield (0, accounts_2.getStakePool)(connection, params.stakePoolId);
    if ((!stakePoolData.parsed.cooldownSeconds ||
        stakePoolData.parsed.cooldownSeconds === 0 ||
        ((stakeEntryData === null || stakeEntryData === void 0 ? void 0 : stakeEntryData.parsed.cooldownStartSeconds) &&
            Date.now() / 1000 -
                stakeEntryData.parsed.cooldownStartSeconds.toNumber() >=
                stakePoolData.parsed.cooldownSeconds)) &&
        (!stakePoolData.parsed.minStakeSeconds ||
            stakePoolData.parsed.minStakeSeconds === 0 ||
            ((stakeEntryData === null || stakeEntryData === void 0 ? void 0 : stakeEntryData.parsed.lastStakedAt) &&
                Date.now() / 1000 - stakeEntryData.parsed.lastStakedAt.toNumber() >=
                    stakePoolData.parsed.minStakeSeconds))) {
        // return receipt mint if its claimed
        yield (0, exports.withReturnReceiptMint)(transaction, connection, wallet, {
            stakeEntryId: stakeEntryId,
        });
    }
    const stakeEntryOriginalMintTokenAccountId = yield (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, connection, params.originalMintId, stakeEntryId, wallet.publicKey, true);
    const userOriginalMintTokenAccountId = yield (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, connection, params.originalMintId, wallet.publicKey, wallet.publicKey);
    const remainingAccounts = yield (0, utils_2.withRemainingAccountsForUnstake)(transaction, connection, wallet, stakeEntryId, stakeEntryData === null || stakeEntryData === void 0 ? void 0 : stakeEntryData.parsed.stakeMint);
    transaction.add((0, instruction_1.unstake)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        stakeEntryId: stakeEntryId,
        originalMintId: params.originalMintId,
        user: wallet.publicKey,
        stakeEntryOriginalMintTokenAccount: stakeEntryOriginalMintTokenAccountId,
        userOriginalMintTokenAccount: userOriginalMintTokenAccountId,
        remainingAccounts,
    }));
    // claim any rewards deserved
    if (rewardDistributorData) {
        yield (0, transaction_1.withClaimRewards)(transaction, connection, wallet, {
            stakePoolId: params.stakePoolId,
            stakeEntryId: stakeEntryId,
        });
    }
    return transaction;
});
exports.withUnstake = withUnstake;
const withUpdateStakePool = (transaction, connection, wallet, params) => {
    transaction.add((0, instruction_1.updateStakePool)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        requiresCreators: params.requiresCreators,
        requiresCollections: params.requiresCollections,
        requiresAuthorization: params.requiresAuthorization,
        overlayText: params.overlayText,
        imageUri: params.imageUri,
        authority: wallet.publicKey,
        resetOnStake: params.resetOnStake,
        cooldownSeconds: params.cooldownSeconds,
        minStakeSeconds: params.minStakeSeconds,
    }));
    return [transaction, params.stakePoolId];
};
exports.withUpdateStakePool = withUpdateStakePool;
const withUpdateTotalStakeSeconds = (transaction, connection, wallet, params) => {
    transaction.add((0, instruction_1.updateTotalStakeSeconds)(connection, wallet, {
        stakEntryId: params.stakeEntryId,
        lastStaker: params.lastStaker,
    }));
    return transaction;
};
exports.withUpdateTotalStakeSeconds = withUpdateTotalStakeSeconds;
const withReturnReceiptMint = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const stakeEntryData = yield (0, common_1.tryGetAccount)(() => (0, accounts_2.getStakeEntry)(connection, params.stakeEntryId));
    if (!stakeEntryData) {
        throw new Error(`Stake entry ${params.stakeEntryId.toString()} not found`);
    }
    if (!stakeEntryData.parsed.stakeMintClaimed &&
        !stakeEntryData.parsed.originalMintClaimed) {
        console.log("No receipt mint to return");
        return transaction;
    }
    const receiptMint = stakeEntryData.parsed.stakeMint && stakeEntryData.parsed.stakeMintClaimed
        ? stakeEntryData.parsed.stakeMint
        : stakeEntryData.parsed.originalMint;
    const tokenManagerId = yield (0, pda_1.tokenManagerAddressFromMint)(connection, receiptMint);
    const tokenManagerData = yield (0, common_1.tryGetAccount)(() => programs_1.tokenManager.accounts.getTokenManager(connection, tokenManagerId));
    if (!tokenManagerData) {
        return transaction;
    }
    const remainingAccountsForReturn = yield (0, tokenManager_1.withRemainingAccountsForReturn)(transaction, connection, wallet, tokenManagerData);
    transaction.add(yield (0, instruction_1.returnReceiptMint)(connection, wallet, {
        stakeEntry: params.stakeEntryId,
        receiptMint: receiptMint,
        tokenManagerKind: tokenManagerData.parsed.kind,
        tokenManagerState: tokenManagerData.parsed.state,
        returnAccounts: remainingAccountsForReturn,
    }));
    return transaction;
});
exports.withReturnReceiptMint = withReturnReceiptMint;
const withCloseStakePool = (transaction, connection, wallet, params) => {
    transaction.add((0, instruction_1.closeStakePool)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        authority: wallet.publicKey,
    }));
    return transaction;
};
exports.withCloseStakePool = withCloseStakePool;
const withCloseStakeEntry = (transaction, connection, wallet, params) => {
    transaction.add((0, instruction_1.closeStakeEntry)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        stakeEntryId: params.stakeEntryId,
        authority: wallet.publicKey,
    }));
    return transaction;
};
exports.withCloseStakeEntry = withCloseStakeEntry;
//# sourceMappingURL=transaction.js.map