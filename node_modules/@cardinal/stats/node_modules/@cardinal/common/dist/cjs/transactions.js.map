{"version":3,"file":"transactions.js","sourceRoot":"","sources":["../../src/transactions.ts"],"names":[],"mappings":";;;;AAAA,oEAA8C;AAG9C;;;;;;;;;;GAUG;AACH,SAAsB,oCAAoC,CACxD,WAA6B,EAC7B,UAA2B,EAC3B,IAAoB,EACpB,KAAqB,EACrB,KAAqB,EACrB,kBAA4B;;QAE5B,MAAM,iBAAiB,GAAG,MAAM,QAAQ,CAAC,KAAK,CAAC,yBAAyB,CACtE,QAAQ,CAAC,2BAA2B,EACpC,QAAQ,CAAC,gBAAgB,EACzB,IAAI,EACJ,KAAK,EACL,kBAAkB,CACnB,CAAC;QACF,MAAM,OAAO,GAAG,MAAM,UAAU,CAAC,cAAc,CAAC,iBAAiB,CAAC,CAAC;QACnE,IAAI,CAAC,OAAO,EAAE;YACZ,WAAW,CAAC,GAAG,CACb,QAAQ,CAAC,KAAK,CAAC,uCAAuC,CACpD,QAAQ,CAAC,2BAA2B,EACpC,QAAQ,CAAC,gBAAgB,EACzB,IAAI,EACJ,iBAAiB,EACjB,KAAK,EACL,KAAK,CACN,CACF,CAAC;SACH;QACD,OAAO,iBAAiB,CAAC;IAC3B,CAAC;CAAA;AA7BD,oFA6BC;AAED;;;;;;;;GAQG;AACI,MAAM,0BAA0B,GAAG,CACxC,UAA2B,EAC3B,GAAqB,EACrB,MAAuC,EACvC,SAAS,GAAG,GAAG,EACwD,EAAE;IACzE,MAAM,OAAO,GAAuB,CAAC,EAAE,CAAC,CAAC;IACzC,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;QACjB,MAAM,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC1C,IAAI,KAAK,EAAE;YACT,IAAI,KAAK,CAAC,MAAM,IAAI,SAAS,EAAE;gBAC7B,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;aACpB;iBAAM;gBACL,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAChB;SACF;IACH,CAAC,CAAC,CAAC;IACH,MAAM,aAAa,GAAG,MAAM,OAAO,CAAC,GAAG,CACrC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAChB,UAAU,CAAC,uBAAuB,CAAC,CAAC,EAAE,MAAyB,CAAC,CACjE,CACF,CAAC;IACF,OAAO,aAAa,CAAC,IAAI,EAAE,CAAC;AAC9B,CAAC,CAAA,CAAC;AAvBW,QAAA,0BAA0B,8BAuBrC","sourcesContent":["import * as splToken from \"@solana/spl-token\";\nimport type * as web3 from \"@solana/web3.js\";\n\n/**\n * Utility function for adding a find or init associated token account instruction to a transaction\n * Useful when using associated token accounts so you can be sure they are created before hand\n * @param transaction\n * @param connection\n * @param mint\n * @param owner\n * @param payer\n * @param allowOwnerOffCurve\n * @returns The associated token account ID that was found or will be created. This also adds the relevent instruction to create it to the transaction if not found\n */\nexport async function withFindOrInitAssociatedTokenAccount(\n  transaction: web3.Transaction,\n  connection: web3.Connection,\n  mint: web3.PublicKey,\n  owner: web3.PublicKey,\n  payer: web3.PublicKey,\n  allowOwnerOffCurve?: boolean\n): Promise<web3.PublicKey> {\n  const associatedAddress = await splToken.Token.getAssociatedTokenAddress(\n    splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\n    splToken.TOKEN_PROGRAM_ID,\n    mint,\n    owner,\n    allowOwnerOffCurve\n  );\n  const account = await connection.getAccountInfo(associatedAddress);\n  if (!account) {\n    transaction.add(\n      splToken.Token.createAssociatedTokenAccountInstruction(\n        splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\n        splToken.TOKEN_PROGRAM_ID,\n        mint,\n        associatedAddress,\n        owner,\n        payer\n      )\n    );\n  }\n  return associatedAddress;\n}\n\n/**\n * Fecthes multiple accounts in batches since there is a limit of\n * 100 accounts per connection.getMultipleAccountsInfo call\n * @param connection\n * @param ids\n * @param config\n * @param batchSize\n * @returns\n */\nexport const getBatchedMultipleAccounts = async (\n  connection: web3.Connection,\n  ids: web3.PublicKey[],\n  config?: web3.GetMultipleAccountsConfig,\n  batchSize = 100\n): Promise<(web3.AccountInfo<Buffer | web3.ParsedAccountData> | null)[]> => {\n  const batches: web3.PublicKey[][] = [[]];\n  ids.forEach((id) => {\n    const batch = batches[batches.length - 1];\n    if (batch) {\n      if (batch.length >= batchSize) {\n        batches.push([id]);\n      } else {\n        batch.push(id);\n      }\n    }\n  });\n  const batchAccounts = await Promise.all(\n    batches.map((b) =>\n      connection.getMultipleAccountsInfo(b, config as web3.Commitment)\n    )\n  );\n  return batchAccounts.flat();\n};\n"]}