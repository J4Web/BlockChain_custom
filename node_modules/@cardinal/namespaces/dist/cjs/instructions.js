"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withCloseNameEntry = exports.withUpdateMintMetadata = exports.withInvalidateReverseEntry = exports.withInvalidateTransferableReverseEntry = exports.withInvalidateExpiredReverseEntry = exports.withRevokeReverseEntry = exports.withUpdateClaimRequest = exports.withCreateClaimRequest = exports.withSetNamespaceReverseEntry = exports.withSetEntryData = exports.withInvalidateNameEntry = exports.withInvalidateTransferableNameEntry = exports.withInvalidateExpiredNameEntry = exports.withRevokeNameEntry = exports.withInitNameEntryMint = exports.withInitNameEntry = exports.withClaimNameEntry = exports.withUpdateNamespace = exports.withCreateNamespace = exports.withInit = void 0;
const tslib_1 = require("tslib");
const certificates_1 = require("@cardinal/certificates");
const common_1 = require("@cardinal/common");
const tokenManager_1 = require("@cardinal/token-manager/dist/cjs/programs/tokenManager");
const accounts_1 = require("@cardinal/token-manager/dist/cjs/programs/tokenManager/accounts");
const pda_1 = require("@cardinal/token-manager/dist/cjs/programs/tokenManager/pda");
const mplTokenMetadata = tslib_1.__importStar(require("@metaplex-foundation/mpl-token-metadata"));
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const splToken = tslib_1.__importStar(require("@solana/spl-token"));
const web3_js_1 = require("@solana/web3.js");
const _1 = require(".");
async function withInit(connection, wallet, rentalPercentage, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [globalContextId] = await (0, _1.findGlobalContextId)();
    transaction.add(namespacesProgram.instruction.initGlobalContext({
        feeBasisPoints: new anchor.BN(rentalPercentage),
    }, {
        accounts: {
            globalContext: globalContextId,
            authority: provider.wallet.publicKey,
            payer: provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withInit = withInit;
async function withCreateNamespace(transaction, connection, wallet, params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(params.namespaceName);
    transaction.add(namespacesProgram.instruction.createNamespace({
        name: params.namespaceName,
        updateAuthority: params.updateAuthority,
        rentAuthority: params.rentAuthority,
        approveAuthority: (_a = params.approveAuthority) !== null && _a !== void 0 ? _a : null,
        schema: (_b = params.schema) !== null && _b !== void 0 ? _b : 0,
        paymentAmountDaily: (_c = params.paymentAmountDaily) !== null && _c !== void 0 ? _c : new anchor.BN(0),
        paymentMint: (_d = params.paymentMint) !== null && _d !== void 0 ? _d : web3_js_1.PublicKey.default,
        minRentalSeconds: (_e = params.minRentalSeconds) !== null && _e !== void 0 ? _e : new anchor.BN(0),
        maxRentalSeconds: (_f = params.maxRentalSeconds) !== null && _f !== void 0 ? _f : null,
        transferableEntries: params.transferableEntries,
        limit: (_g = params.limit) !== null && _g !== void 0 ? _g : null,
        maxExpiration: (_h = params.maxExpiration) !== null && _h !== void 0 ? _h : null,
        invalidationType: ((_j = params.invalidationType) !== null && _j !== void 0 ? _j : params.transferableEntries)
            ? tokenManager_1.InvalidationType.Invalidate
            : tokenManager_1.InvalidationType.Return,
    }, {
        accounts: {
            namespace: namespaceId,
            authority: provider.wallet.publicKey,
            payer: provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withCreateNamespace = withCreateNamespace;
async function withUpdateNamespace(transaction, connection, wallet, namespaceName, params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    transaction.add(namespacesProgram.instruction.updateNamespace({
        updateAuthority: (_a = params.updateAuthority) !== null && _a !== void 0 ? _a : null,
        rentAuthority: (_b = params.rentAuthority) !== null && _b !== void 0 ? _b : null,
        approveAuthority: (_c = params.approveAuthority) !== null && _c !== void 0 ? _c : null,
        paymentAmountDaily: (_d = params.paymentAmountDaily) !== null && _d !== void 0 ? _d : null,
        paymentMint: (_e = params.paymentMint) !== null && _e !== void 0 ? _e : null,
        minRentalSeconds: (_f = params.minRentalSeconds) !== null && _f !== void 0 ? _f : null,
        maxRentalSeconds: (_g = params.maxRentalSeconds) !== null && _g !== void 0 ? _g : null,
        transferableEntries: (_h = params.transferableEntries) !== null && _h !== void 0 ? _h : null,
        limit: (_j = params.limit) !== null && _j !== void 0 ? _j : null,
        maxExpiration: (_k = params.maxExpiration) !== null && _k !== void 0 ? _k : null,
    }, {
        accounts: {
            namespace: namespaceId,
            updateAuthority: provider.wallet.publicKey,
        },
    }));
    return transaction;
}
exports.withUpdateNamespace = withUpdateNamespace;
async function withClaimNameEntry(transaction, connection, wallet, namespaceName, entryName, mintId, duration, requestor = wallet.publicKey, payer = wallet.publicKey) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [entryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    const [claimRequestId] = await (0, _1.findClaimRequestId)(namespaceId, entryName, requestor);
    const [tokenManagerId] = await (0, pda_1.findTokenManagerAddress)(mintId);
    const namespace = await (0, _1.getNamespace)(connection, namespaceId);
    const namespaceTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mintId, namespaceId, true);
    const tokenManagerTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mintId, tokenManagerId, true);
    const recipientTokenAccount = await (0, certificates_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, mintId, wallet.publicKey, payer, true);
    const [mintCounterId] = await (0, pda_1.findMintCounterId)(mintId);
    const remainingAccountsForClaim = await (0, _1.withRemainingAccountsForClaim)(connection, transaction, wallet, namespaceId, tokenManagerId, duration && duration > 0 ? duration : undefined);
    const remainingAccountsForKind = await (0, tokenManager_1.getRemainingAccountsForKind)(mintId, namespace.parsed.transferableEntries
        ? tokenManager_1.TokenManagerKind.Unmanaged
        : tokenManager_1.TokenManagerKind.Edition);
    transaction.add(namespacesProgram.instruction.claimNameEntry({
        duration: duration && duration > 0 ? new anchor.BN(duration) : null,
    }, {
        accounts: {
            namespace: namespaceId,
            nameEntry: entryId,
            requestor: requestor,
            recipient: wallet.publicKey,
            payer: payer,
            claimRequest: claimRequestId,
            mint: mintId,
            namespaceTokenAccount: namespaceTokenAccountId,
            tokenManager: tokenManagerId,
            tokenManagerTokenAccount: tokenManagerTokenAccountId,
            mintCounter: mintCounterId,
            recipientTokenAccount: recipientTokenAccount,
            tokenManagerProgram: tokenManager_1.TOKEN_MANAGER_ADDRESS,
            tokenProgram: splToken.TOKEN_PROGRAM_ID,
            associatedToken: splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
        remainingAccounts: [
            ...remainingAccountsForClaim,
            ...remainingAccountsForKind,
        ],
    }));
    return transaction;
}
exports.withClaimNameEntry = withClaimNameEntry;
async function withInitNameEntry(transaction, connection, wallet, namespaceName, entryName) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [entryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    transaction.add(namespacesProgram.instruction.initNameEntry({
        name: entryName,
    }, {
        accounts: {
            namespace: namespaceId,
            nameEntry: entryId,
            payer: provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withInitNameEntry = withInitNameEntry;
async function withInitNameEntryMint(transaction, connection, wallet, namespaceName, entryName, mintKeypair) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [entryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    const namespaceTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mintKeypair.publicKey, namespaceId, true);
    const mintMetadataId = await mpl_token_metadata_1.Metadata.getPDA(mintKeypair.publicKey);
    const mintMasterEditionId = await mpl_token_metadata_1.MasterEdition.getPDA(mintKeypair.publicKey);
    transaction.add(namespacesProgram.instruction.initNameEntryMint({
        accounts: {
            namespace: namespaceId,
            nameEntry: entryId,
            payer: provider.wallet.publicKey,
            namespaceTokenAccount: namespaceTokenAccountId,
            mint: mintKeypair.publicKey,
            mintMetadata: mintMetadataId,
            masterEdition: mintMasterEditionId,
            tokenMetadataProgram: mplTokenMetadata.MetadataProgram.PUBKEY,
            tokenProgram: splToken.TOKEN_PROGRAM_ID,
            associatedToken: splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withInitNameEntryMint = withInitNameEntryMint;
async function withRevokeNameEntry(transaction, connection, wallet, namespaceName, entryName, mintId, claimRequestId) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [entryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    const nameEntry = await (0, _1.getNameEntry)(connection, namespaceName, entryName);
    const [tokenManagerId] = await (0, pda_1.findTokenManagerAddress)(mintId);
    const tokenManagerData = await (0, accounts_1.getTokenManager)(connection, tokenManagerId);
    const tokenManagerTokenAccount = await (0, certificates_1.withFindOrInitAssociatedTokenAccount)(transaction, connection, mintId, tokenManagerId, wallet.publicKey, true);
    const recipientTokenAccount = await (0, common_1.findAta)(nameEntry.parsed.mint, provider.wallet.publicKey, true);
    const remainingAccountsForKind = await (0, tokenManager_1.getRemainingAccountsForKind)(mintId, tokenManager_1.TokenManagerKind.Edition);
    const remainingAccountsForReturn = await (0, tokenManager_1.withRemainingAccountsForReturn)(transaction, connection, wallet, tokenManagerData, true);
    transaction.add(namespacesProgram.instruction.revokeNameEntry({
        accounts: {
            namespace: namespaceId,
            nameEntry: entryId,
            claimRequest: claimRequestId,
            invalidator: provider.wallet.publicKey,
            tokenManager: tokenManagerId,
            mint: mintId,
            tokenManagerTokenAccount: tokenManagerTokenAccount,
            recipientTokenAccount: recipientTokenAccount,
            tokenManagerProgram: tokenManager_1.TOKEN_MANAGER_ADDRESS,
            tokenProgram: splToken.TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        },
        remainingAccounts: [
            ...remainingAccountsForKind,
            ...remainingAccountsForReturn,
        ],
    }));
    return transaction;
}
exports.withRevokeNameEntry = withRevokeNameEntry;
async function withInvalidateExpiredNameEntry(transaction, connection, wallet, params) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(params.namespaceName);
    const [nameEntryId] = await (0, _1.findNameEntryId)(namespaceId, params.entryName);
    const namespaceTokenAccountId = await (0, common_1.findAta)(params.mintId, namespaceId, true);
    transaction.add(namespacesProgram.instruction.invalidateExpiredNameEntry({
        accounts: {
            namespace: namespaceId,
            nameEntry: nameEntryId,
            namespaceTokenAccount: namespaceTokenAccountId,
            invalidator: params.invalidator || namespaceId,
        },
    }));
    return transaction;
}
exports.withInvalidateExpiredNameEntry = withInvalidateExpiredNameEntry;
async function withInvalidateTransferableNameEntry(transaction, connection, wallet, params) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(params.namespaceName);
    const [nameEntryId] = await (0, _1.findNameEntryId)(namespaceId, params.entryName);
    const [tokenManagerId] = await (0, pda_1.findTokenManagerAddress)(params.mintId);
    transaction.add(namespacesProgram.instruction.invalidateTransferableNameEntry({
        accounts: {
            namespace: namespaceId,
            nameEntry: nameEntryId,
            tokenManager: tokenManagerId,
            invalidator: params.invalidator || namespaceId,
        },
    }));
    return transaction;
}
exports.withInvalidateTransferableNameEntry = withInvalidateTransferableNameEntry;
async function withInvalidateNameEntry(transaction, connection, wallet, params) {
    if (params.transferable) {
        return withInvalidateTransferableNameEntry(transaction, connection, wallet, params);
    }
    else {
        return withInvalidateExpiredNameEntry(transaction, connection, wallet, params);
    }
}
exports.withInvalidateNameEntry = withInvalidateNameEntry;
async function withSetEntryData(connection, wallet, namespaceName, entryName, mintId, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [entryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    const entry = await namespacesProgram.account.entry.fetch(entryId);
    const [tokenManagerId] = await (0, pda_1.findTokenManagerAddress)(mintId);
    const userTokenAccountId = await (0, certificates_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, entry.mint, provider.wallet.publicKey, provider.wallet.publicKey);
    transaction.add(namespacesProgram.instruction.setNameEntryData({
        accounts: {
            namespace: namespaceId,
            nameEntry: entryId,
            userTokenAccount: userTokenAccountId,
            tokenManager: tokenManagerId,
            user: provider.wallet.publicKey,
        },
    }));
    return transaction;
}
exports.withSetEntryData = withSetEntryData;
async function withSetNamespaceReverseEntry(transaction, connection, wallet, namespaceName, entryName, mintId, payer = wallet.publicKey) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [entryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    const [reverseEntryId] = await (0, _1.findReverseEntryId)(namespaceId, wallet.publicKey);
    const userTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mintId, provider.wallet.publicKey);
    const [tokenManagerId] = await (0, pda_1.findTokenManagerAddress)(mintId);
    transaction.add(namespacesProgram.instruction.setNamespaceReverseEntry({
        accounts: {
            namespace: namespaceId,
            nameEntry: entryId,
            reverseEntry: reverseEntryId,
            userTokenAccount: userTokenAccountId,
            tokenManager: tokenManagerId,
            user: provider.wallet.publicKey,
            payer: payer,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withSetNamespaceReverseEntry = withSetNamespaceReverseEntry;
async function withCreateClaimRequest(connection, wallet, namespaceName, entryName, user, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [claimRequestId, claimRequestBump] = await (0, _1.findClaimRequestId)(namespaceId, entryName, user);
    transaction.add(namespacesProgram.instruction.createClaimRequest(entryName, claimRequestBump, user, {
        accounts: {
            namespace: namespaceId,
            payer: provider.wallet.publicKey,
            claimRequest: claimRequestId,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withCreateClaimRequest = withCreateClaimRequest;
async function withUpdateClaimRequest(connection, wallet, namespaceName, entryName, rentRequestId, isApproved, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [nameEntryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    transaction.add(namespacesProgram.instruction.updateClaimRequest(isApproved, {
        accounts: {
            nameEntry: nameEntryId,
            namespace: namespaceId,
            approveAuthority: provider.wallet.publicKey,
            rentRequest: rentRequestId,
        },
    }));
    return transaction;
}
exports.withUpdateClaimRequest = withUpdateClaimRequest;
async function withRevokeReverseEntry(transaction, connection, wallet, namespaceName, entryName, reverseEntryId, claimRequestId) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(namespaceName);
    const [nameEntryId] = await (0, _1.findNameEntryId)(namespaceId, entryName);
    transaction.add(namespacesProgram.instruction.revokeReverseEntry({
        accounts: {
            namespace: namespaceId,
            nameEntry: nameEntryId,
            reverseEntry: reverseEntryId,
            claimRequest: claimRequestId,
            invalidator: wallet.publicKey,
        },
    }));
    return transaction;
}
exports.withRevokeReverseEntry = withRevokeReverseEntry;
async function withInvalidateExpiredReverseEntry(transaction, connection, wallet, params) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(params.namespaceName);
    const [nameEntryId] = await (0, _1.findNameEntryId)(namespaceId, params.entryName);
    const namespaceTokenAccountId = await (0, common_1.findAta)(params.mintId, namespaceId, true);
    transaction.add(namespacesProgram.instruction.invalidateExpiredReverseEntry({
        accounts: {
            namespace: namespaceId,
            nameEntry: nameEntryId,
            namespaceTokenAccount: namespaceTokenAccountId,
            reverseNameEntry: params.reverseEntryId,
            invalidator: params.invalidator || namespaceId,
        },
    }));
    return transaction;
}
exports.withInvalidateExpiredReverseEntry = withInvalidateExpiredReverseEntry;
async function withInvalidateTransferableReverseEntry(transaction, connection, wallet, params) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await (0, _1.findNamespaceId)(params.namespaceName);
    const [nameEntryId] = await (0, _1.findNameEntryId)(namespaceId, params.entryName);
    const [tokenManagerId] = await (0, pda_1.findTokenManagerAddress)(params.mintId);
    transaction.add(namespacesProgram.instruction.invalidateTransferableReverseEntry({
        accounts: {
            namespace: namespaceId,
            nameEntry: nameEntryId,
            tokenManager: tokenManagerId,
            reverseNameEntry: params.reverseEntryId,
            invalidator: params.invalidator || namespaceId,
        },
    }));
    return transaction;
}
exports.withInvalidateTransferableReverseEntry = withInvalidateTransferableReverseEntry;
async function withInvalidateReverseEntry(transaction, connection, wallet, params) {
    if (params.transferable) {
        return withInvalidateTransferableReverseEntry(transaction, connection, wallet, params);
    }
    else {
        return withInvalidateExpiredReverseEntry(transaction, connection, wallet, params);
    }
}
exports.withInvalidateReverseEntry = withInvalidateReverseEntry;
async function withUpdateMintMetadata(connection, wallet, namespaceId, entryId, mintId, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    const mintMetadataId = await mpl_token_metadata_1.Metadata.getPDA(mintId);
    transaction.add(namespacesProgram.instruction.updateNameEntryMintMetadata({
        accounts: {
            namespace: namespaceId,
            updateAuthority: provider.wallet.publicKey,
            nameEntry: entryId,
            mintMetadata: mintMetadataId,
            tokenMetadataProgram: mplTokenMetadata.MetadataProgram.PUBKEY,
        },
    }));
    return transaction;
}
exports.withUpdateMintMetadata = withUpdateMintMetadata;
function withCloseNameEntry(connection, wallet, namespaceId, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(_1.NAMESPACES_IDL, _1.NAMESPACES_PROGRAM_ID, provider);
    transaction.add(namespacesProgram.instruction.closeNameEntry({
        accounts: {
            namespace: namespaceId,
            invalidator: wallet.publicKey,
        },
    }));
    return transaction;
}
exports.withCloseNameEntry = withCloseNameEntry;
//# sourceMappingURL=instructions.js.map