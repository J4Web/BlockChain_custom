"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withRemainingAccountsForClaim = exports.nameForDisplay = exports.tryGetName = exports.displayAddress = exports.shortenAddress = exports.breakIdentity = exports.breakName = exports.formatName = void 0;
const common_1 = require("@cardinal/common");
const paymentManager_1 = require("@cardinal/token-manager/dist/cjs/programs/paymentManager");
const accounts_1 = require("@cardinal/token-manager/dist/cjs/programs/paymentManager/accounts");
const pda_1 = require("@cardinal/token-manager/dist/cjs/programs/paymentManager/pda");
const timeInvalidator_1 = require("@cardinal/token-manager/dist/cjs/programs/timeInvalidator");
const pda_2 = require("@cardinal/token-manager/dist/cjs/programs/timeInvalidator/pda");
const tokenManager_1 = require("@cardinal/token-manager/dist/cjs/programs/tokenManager");
const web3_js_1 = require("@solana/web3.js");
const accounts_2 = require("./accounts");
const constants_1 = require("./constants");
function formatName(namespace, name) {
    return constants_1.IDENTITIES.includes(namespace) ? `@${name}` : `${name}.${namespace}`;
}
exports.formatName = formatName;
function breakName(fullName) {
    if (fullName.startsWith("@")) {
        return ["twitter", fullName.split("@")[1]];
    }
    const [entryName, namespace] = fullName.split(".");
    return [namespace, entryName];
}
exports.breakName = breakName;
function breakIdentity(fullName) {
    if (fullName.startsWith("@")) {
        const namespace = fullName.split(":")[1] || "twitter";
        const entryName = fullName.includes(":")
            ? fullName.split("@")[1].split(":")[0]
            : fullName.split("@")[1];
        return [namespace, entryName];
    }
    const [entryName, namespace] = fullName.split(".");
    return [namespace, entryName];
}
exports.breakIdentity = breakIdentity;
/**
 * shorten the checksummed version of the input address to have 4 characters at start and end
 * @param address
 * @param chars
 * @returns
 */
function shortenAddress(address, chars = 5) {
    return `${address.substring(0, chars)}...${address.substring(address.length - chars)}`;
}
exports.shortenAddress = shortenAddress;
function displayAddress(address, shorten = true) {
    return shorten ? shortenAddress(address) : address;
}
exports.displayAddress = displayAddress;
async function tryGetName(connection, pubkey, namespace, disallowGlobal) {
    try {
        const reverseEntry = await (0, accounts_2.getReverseEntry)(connection, pubkey, namespace, disallowGlobal);
        return formatName(reverseEntry.parsed.namespaceName, reverseEntry.parsed.entryName);
    }
    catch (e) {
        console.log(e);
    }
    return undefined;
}
exports.tryGetName = tryGetName;
async function nameForDisplay(connection, pubkey, namespace) {
    const name = await tryGetName(connection, pubkey, namespace);
    return name || displayAddress(pubkey.toString());
}
exports.nameForDisplay = nameForDisplay;
const withRemainingAccountsForClaim = async (connection, transaction, wallet, namespaceId, tokenManagerId, duration) => {
    const namespace = await (0, accounts_2.getNamespace)(connection, namespaceId);
    if (namespace.parsed.paymentAmountDaily.toNumber() > 0 ||
        namespace.parsed.maxExpiration) {
        const [paymentManagerId] = await (0, pda_1.findPaymentManagerAddress)(constants_1.DEFAULT_PAYMENT_MANAGER);
        const [timeInvalidatorId] = await (0, pda_2.findTimeInvalidatorAddress)(tokenManagerId);
        const accounts = [
            {
                pubkey: namespace.parsed.paymentMint,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: paymentManagerId,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: timeInvalidatorId,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: timeInvalidator_1.TIME_INVALIDATOR_ADDRESS,
                isSigner: false,
                isWritable: false,
            },
        ];
        if (duration && duration > 0) {
            const [paymentTokenAccountId] = await (0, tokenManager_1.withRemainingAccountsForPayment)(transaction, connection, wallet, namespace.parsed.paymentMint, namespaceId, paymentManagerId);
            const payerTokenAccountId = await (0, common_1.findAta)(namespace.parsed.paymentMint, wallet.publicKey);
            const paymentManagerData = await (0, common_1.tryGetAccount)(() => (0, accounts_1.getPaymentManager)(connection, paymentManagerId));
            const feeCollectorTokenAccountId = await (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, connection, namespace.parsed.paymentMint, paymentManagerData
                ? paymentManagerData.parsed.feeCollector
                : web3_js_1.PublicKey.default, wallet.publicKey, true);
            accounts.concat([
                {
                    pubkey: payerTokenAccountId,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: paymentTokenAccountId,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: feeCollectorTokenAccountId,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: paymentManager_1.PAYMENT_MANAGER_ADDRESS,
                    isSigner: false,
                    isWritable: false,
                },
            ]);
        }
        return accounts;
    }
    else {
        return [];
    }
};
exports.withRemainingAccountsForClaim = withRemainingAccountsForClaim;
//# sourceMappingURL=utils.js.map