"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withSetReverseEntry = exports.withSetEntryData = exports.withRevokeEntry = exports.withInitEntry = exports.withClaimEntry = void 0;
const tslib_1 = require("tslib");
const certificate = tslib_1.__importStar(require("@cardinal/certificates"));
const certificates_1 = require("@cardinal/certificates");
const common_1 = require("@cardinal/common");
const mplTokenMetadata = tslib_1.__importStar(require("@metaplex-foundation/mpl-token-metadata"));
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const splToken = tslib_1.__importStar(require("@solana/spl-token"));
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
async function withClaimEntry(connection, wallet, namespaceName, entryName, certificateMintId, duration, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(constants_1.NAMESPACES_IDL, constants_1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.NAMESPACE_SEED),
        anchor.utils.bytes.utf8.encode(namespaceName),
    ], namespacesProgram.programId);
    const [entryId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.ENTRY_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
    ], namespacesProgram.programId);
    const [claimRequestId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.CLAIM_REQUEST_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
        provider.wallet.publicKey.toBytes(),
    ], namespacesProgram.programId);
    const namespace = await namespacesProgram.account.namespace.fetch(namespaceId);
    const [certificateId, certificateBump] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(certificates_1.CERTIFICATE_SEED),
        certificateMintId.toBuffer(),
    ], certificates_1.CERTIFICATE_PROGRAM_ID);
    const [mintManagerId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(certificates_1.MINT_MANAGER_SEED),
        certificateMintId.toBytes(),
    ], certificates_1.CERTIFICATE_PROGRAM_ID);
    const namespaceCertificateTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, certificateMintId, namespaceId, true);
    const certificatePaymentTokenAccountId = await (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, namespace.paymentMint, certificateId, provider.wallet.publicKey, true);
    const userCertificateTokenAccountId = await (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, certificateMintId, provider.wallet.publicKey, provider.wallet.publicKey);
    const userPaymentTokenAccountId = await (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, namespace.paymentMint, provider.wallet.publicKey, provider.wallet.publicKey);
    const certificateTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, certificateMintId, certificateId, true);
    transaction.add(namespacesProgram.instruction.claimEntry({
        duration: duration > 0 ? new anchor.BN(duration) : null,
        certificateBump,
    }, {
        accounts: {
            namespace: namespaceId,
            entry: entryId,
            user: provider.wallet.publicKey,
            payer: provider.wallet.publicKey,
            paymentMint: namespace.paymentMint,
            claimRequest: claimRequestId,
            // CPI accounts
            mintManager: mintManagerId,
            certificate: certificateId,
            certificateMint: certificateMintId,
            certificateTokenAccount: certificateTokenAccountId,
            certificatePaymentTokenAccount: certificatePaymentTokenAccountId,
            userCertificateTokenAccount: userCertificateTokenAccountId,
            userPaymentTokenAccount: userPaymentTokenAccountId,
            namespaceCertificateTokenAccount: namespaceCertificateTokenAccountId,
            // programs
            certificateProgram: certificates_1.CERTIFICATE_PROGRAM_ID,
            tokenProgram: splToken.TOKEN_PROGRAM_ID,
            associatedToken: splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withClaimEntry = withClaimEntry;
async function withInitEntry(connection, wallet, certificateMintId, namespaceName, entryName, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(constants_1.NAMESPACES_IDL, constants_1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.NAMESPACE_SEED),
        anchor.utils.bytes.utf8.encode(namespaceName),
    ], namespacesProgram.programId);
    const [entryId, entryBump] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.ENTRY_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
    ], namespacesProgram.programId);
    const [mintManagerId, mintManagerBump] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(certificates_1.MINT_MANAGER_SEED),
        certificateMintId.toBytes(),
    ], certificates_1.CERTIFICATE_PROGRAM_ID);
    const [certificateMintMetadataId] = await web3_js_1.PublicKey.findProgramAddress([
        Buffer.from(mplTokenMetadata.MetadataProgram.PREFIX),
        mplTokenMetadata.MetadataProgram.PUBKEY.toBuffer(),
        certificateMintId.toBuffer(),
    ], mplTokenMetadata.MetadataProgram.PUBKEY);
    const mintBalanceNeeded = await splToken.Token.getMinBalanceRentForExemptMint(provider.connection);
    transaction.add(web3_js_1.SystemProgram.createAccount({
        fromPubkey: provider.wallet.publicKey,
        newAccountPubkey: certificateMintId,
        lamports: mintBalanceNeeded,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        space: splToken.MintLayout.span,
        programId: splToken.TOKEN_PROGRAM_ID,
    }));
    const namespaceCertificateTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, certificateMintId, namespaceId, true);
    transaction.add(namespacesProgram.instruction.initEntry({
        name: entryName,
        entryBump,
        mintManagerBump,
    }, {
        accounts: {
            namespace: namespaceId,
            entry: entryId,
            payer: provider.wallet.publicKey,
            namespaceCertificateTokenAccount: namespaceCertificateTokenAccountId,
            // cpi
            mintManager: mintManagerId,
            certificateMint: certificateMintId,
            certificateMintMetadata: certificateMintMetadataId,
            // programs
            certificateProgram: certificates_1.CERTIFICATE_PROGRAM_ID,
            tokenMetadataProgram: mplTokenMetadata.MetadataProgram.PUBKEY,
            tokenProgram: splToken.TOKEN_PROGRAM_ID,
            associatedToken: splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withInitEntry = withInitEntry;
async function withRevokeEntry(connection, wallet, namespaceName, entryName, certificateMintId, certificateOwnerId, claimRequestId, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(constants_1.NAMESPACES_IDL, constants_1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.NAMESPACE_SEED),
        anchor.utils.bytes.utf8.encode(namespaceName),
    ], namespacesProgram.programId);
    const [entryId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.ENTRY_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
    ], namespacesProgram.programId);
    const namespace = await namespacesProgram.account.namespace.fetch(namespaceId);
    const [certificateId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(certificates_1.CERTIFICATE_SEED),
        certificateMintId.toBuffer(),
    ], certificates_1.CERTIFICATE_PROGRAM_ID);
    const [mintManagerId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(certificates_1.MINT_MANAGER_SEED),
        certificateMintId.toBytes(),
    ], certificates_1.CERTIFICATE_PROGRAM_ID);
    const namespaceCertificateTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, certificateMintId, namespaceId, true);
    const namespacePaymentTokenAccountId = await (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, namespace.paymentMint, namespaceId, provider.wallet.publicKey, true);
    const certificatePaymentTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, namespace.paymentMint, certificateId, true);
    const userCertificateTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, certificateMintId, certificateOwnerId);
    const userPaymentTokenAccountId = await (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, namespace.paymentMint, certificateOwnerId, provider.wallet.publicKey);
    const certificateTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, certificateMintId, certificateId, true);
    transaction.add(namespacesProgram.instruction.revokeEntry({
        accounts: {
            namespace: namespaceId,
            entry: entryId,
            claimRequest: claimRequestId,
            namespaceCertificateTokenAccount: namespaceCertificateTokenAccountId,
            namespacePaymentTokenAccount: namespacePaymentTokenAccountId,
            invalidator: provider.wallet.publicKey,
            // CPI accounts
            mintManager: mintManagerId,
            certificate: certificateId,
            certificateMint: certificateMintId,
            certificateTokenAccount: certificateTokenAccountId,
            certificatePaymentTokenAccount: certificatePaymentTokenAccountId,
            userCertificateTokenAccount: userCertificateTokenAccountId,
            userPaymentTokenAccount: userPaymentTokenAccountId,
            // programs
            certificateProgram: certificates_1.CERTIFICATE_PROGRAM_ID,
            tokenProgram: splToken.TOKEN_PROGRAM_ID,
        },
    }));
    return transaction;
}
exports.withRevokeEntry = withRevokeEntry;
async function withSetEntryData(connection, wallet, namespaceName, entryName, entryData, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(constants_1.NAMESPACES_IDL, constants_1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.NAMESPACE_SEED),
        anchor.utils.bytes.utf8.encode(namespaceName),
    ], namespacesProgram.programId);
    const [entryId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.ENTRY_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
    ], namespacesProgram.programId);
    const entry = await namespacesProgram.account.entry.fetch(entryId);
    const [certificateId] = await certificate.certificateIdForMint(entry.mint);
    const userCertificateTokenAccountId = await (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, provider.connection, entry.mint, provider.wallet.publicKey, provider.wallet.publicKey);
    transaction.add(namespacesProgram.instruction.setEntryData(entryData, {
        accounts: {
            namespace: namespaceId,
            entry: entryId,
            userCertificateTokenAccount: userCertificateTokenAccountId,
            certificate: certificateId,
            user: provider.wallet.publicKey,
            payer: provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withSetEntryData = withSetEntryData;
async function withSetReverseEntry(connection, wallet, namespaceName, entryName, certificateMintId, transaction) {
    const provider = new anchor.AnchorProvider(connection, wallet, {});
    const namespacesProgram = new anchor.Program(constants_1.NAMESPACES_IDL, constants_1.NAMESPACES_PROGRAM_ID, provider);
    const [namespaceId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.NAMESPACE_SEED),
        anchor.utils.bytes.utf8.encode(namespaceName),
    ], namespacesProgram.programId);
    const [entryId] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.ENTRY_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
    ], namespacesProgram.programId);
    const [reverseEntryId, reverseEntryBump] = await web3_js_1.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(constants_1.REVERSE_ENTRY_SEED),
        wallet.publicKey.toBytes(),
    ], namespacesProgram.programId);
    const [certificateId] = await certificate.certificateIdForMint(certificateMintId);
    const userCertificateTokenAccountId = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, certificateMintId, provider.wallet.publicKey);
    transaction.add(namespacesProgram.instruction.setReverseEntry(reverseEntryBump, {
        accounts: {
            namespace: namespaceId,
            entry: entryId,
            reverseEntry: reverseEntryId,
            userCertificateTokenAccount: userCertificateTokenAccountId,
            certificate: certificateId,
            user: provider.wallet.publicKey,
            payer: provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
        },
    }));
    return transaction;
}
exports.withSetReverseEntry = withSetReverseEntry;
//# sourceMappingURL=deprecated.js.map