{"version":3,"file":"transaction.js","sourceRoot":"","sources":["../../src/transaction.ts"],"names":[],"mappings":"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","sourcesContent":["import { BN } from \"@project-serum/anchor\";\nimport type { Wallet } from \"@saberhq/solana-contrib\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport type { Connection, PublicKey, Transaction } from \"@solana/web3.js\";\nimport { Keypair } from \"@solana/web3.js\";\n\nimport { findAta } from \".\";\nimport {\n  claimApprover,\n  timeInvalidator,\n  tokenManager,\n  useInvalidator,\n} from \"./programs\";\nimport type { ClaimApproverParams } from \"./programs/claimApprover/instruction\";\nimport type { TimeInvalidationParams } from \"./programs/timeInvalidator/instruction\";\nimport { shouldTimeInvalidate } from \"./programs/timeInvalidator/utils\";\nimport type { TokenManagerData } from \"./programs/tokenManager\";\nimport {\n  InvalidationType,\n  TokenManagerKind,\n  TokenManagerState,\n} from \"./programs/tokenManager\";\nimport { tokenManagerAddressFromMint } from \"./programs/tokenManager/pda\";\nimport {\n  withRemainingAccountsForPayment,\n  withRemainingAccountsForReturn,\n} from \"./programs/tokenManager/utils\";\nimport type { UseInvalidationParams } from \"./programs/useInvalidator/instruction\";\nimport type { AccountData } from \"./utils\";\nimport { tryGetAccount, withFindOrInitAssociatedTokenAccount } from \"./utils\";\n\nexport type IssueParameters = {\n  claimPayment?: ClaimApproverParams;\n  timeInvalidation?: TimeInvalidationParams;\n  useInvalidation?: UseInvalidationParams;\n  mint: PublicKey;\n  amount?: BN;\n  issuerTokenAccountId: PublicKey;\n  visibility?: \"private\" | \"public\";\n  kind?: TokenManagerKind;\n  invalidationType?: InvalidationType;\n  receiptOptions?: {\n    receiptMintKeypair: Keypair;\n  };\n  customInvalidators?: PublicKey[];\n};\n\n/**\n * Main method for issuing any managed token\n * Allows for optional payment, optional usages or expiration and includes a otp for private links\n * @param connection\n * @param wallet\n * @param parameters\n * @returns Transaction, public key for the created token manager and a otp if necessary for private links\n */\nexport const withIssueToken = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  {\n    claimPayment,\n    timeInvalidation,\n    useInvalidation,\n    mint,\n    amount = new BN(1),\n    issuerTokenAccountId,\n    kind = TokenManagerKind.Managed,\n    invalidationType = InvalidationType.Return,\n    visibility = \"public\",\n    receiptOptions = undefined,\n    customInvalidators = undefined,\n  }: IssueParameters\n): Promise<[Transaction, PublicKey, Keypair | undefined]> => {\n  // init token manager\n  const numInvalidator =\n    (customInvalidators ? customInvalidators.length : 0) +\n    (useInvalidation && timeInvalidation\n      ? 2\n      : useInvalidation || timeInvalidation\n      ? 1\n      : 0);\n  const [tokenManagerIx, tokenManagerId] = await tokenManager.instruction.init(\n    connection,\n    wallet,\n    mint,\n    issuerTokenAccountId,\n    amount,\n    kind,\n    invalidationType,\n    numInvalidator\n  );\n  transaction.add(tokenManagerIx);\n\n  //////////////////////////////\n  /////// claim approver ///////\n  //////////////////////////////\n  let otp;\n  if (claimPayment) {\n    if (visibility === \"private\") {\n      throw new Error(\"Private links do not currently support payment\");\n    }\n    const [paidClaimApproverIx, paidClaimApproverId] =\n      await claimApprover.instruction.init(\n        connection,\n        wallet,\n        tokenManagerId,\n        claimPayment\n      );\n    transaction.add(paidClaimApproverIx);\n    transaction.add(\n      tokenManager.instruction.setClaimApprover(\n        connection,\n        wallet,\n        tokenManagerId,\n        paidClaimApproverId\n      )\n    );\n  } else if (visibility === \"private\") {\n    otp = Keypair.generate();\n    transaction.add(\n      tokenManager.instruction.setClaimApprover(\n        connection,\n        wallet,\n        tokenManagerId,\n        otp.publicKey\n      )\n    );\n  }\n\n  //////////////////////////////\n  /////// time invalidator /////\n  //////////////////////////////\n  if (timeInvalidation) {\n    const [timeInvalidatorIx, timeInvalidatorId] =\n      await timeInvalidator.instruction.init(\n        connection,\n        wallet,\n        tokenManagerId,\n        timeInvalidation\n      );\n    transaction.add(timeInvalidatorIx);\n    transaction.add(\n      tokenManager.instruction.addInvalidator(\n        connection,\n        wallet,\n        tokenManagerId,\n        timeInvalidatorId\n      )\n    );\n  } else {\n    const [timeInvalidatorId] =\n      await timeInvalidator.pda.findTimeInvalidatorAddress(tokenManagerId);\n    const timeInvalidatorData = await tryGetAccount(() =>\n      timeInvalidator.accounts.getTimeInvalidator(connection, timeInvalidatorId)\n    );\n    if (timeInvalidatorData) {\n      transaction.add(\n        timeInvalidator.instruction.close(\n          connection,\n          wallet,\n          timeInvalidatorId,\n          tokenManagerId,\n          timeInvalidatorData.parsed.collector\n        )\n      );\n    }\n  }\n\n  //////////////////////////////\n  /////////// usages ///////////\n  //////////////////////////////\n  if (useInvalidation) {\n    const [useInvalidatorIx, useInvalidatorId] =\n      await useInvalidator.instruction.init(\n        connection,\n        wallet,\n        tokenManagerId,\n        useInvalidation\n      );\n    transaction.add(useInvalidatorIx);\n    transaction.add(\n      tokenManager.instruction.addInvalidator(\n        connection,\n        wallet,\n        tokenManagerId,\n        useInvalidatorId\n      )\n    );\n  } else {\n    const [useInvalidatorId] =\n      await useInvalidator.pda.findUseInvalidatorAddress(tokenManagerId);\n    const useInvalidatorData = await tryGetAccount(() =>\n      useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId)\n    );\n    if (useInvalidatorData) {\n      transaction.add(\n        useInvalidator.instruction.close(\n          connection,\n          wallet,\n          useInvalidatorId,\n          tokenManagerId,\n          useInvalidatorData.parsed.collector\n        )\n      );\n    }\n  }\n\n  /////////////////////////////////////////\n  //////////// custom invalidators ////////\n  /////////////////////////////////////////\n  if (customInvalidators) {\n    for (const invalidator of customInvalidators) {\n      transaction.add(\n        tokenManager.instruction.addInvalidator(\n          connection,\n          wallet,\n          tokenManagerId,\n          invalidator\n        )\n      );\n    }\n  }\n\n  if (kind === TokenManagerKind.Managed) {\n    const [mintManagerIx, mintManagerId] =\n      await tokenManager.instruction.creatMintManager(connection, wallet, mint);\n\n    const mintManagerData = await tryGetAccount(() =>\n      tokenManager.accounts.getMintManager(connection, mintManagerId)\n    );\n    if (!mintManagerData) {\n      transaction.add(mintManagerIx);\n    }\n  }\n\n  // issuer\n  const tokenManagerTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n    transaction,\n    connection,\n    mint,\n    tokenManagerId,\n    wallet.publicKey,\n    true\n  );\n\n  transaction.add(\n    tokenManager.instruction.issue(\n      connection,\n      wallet,\n      tokenManagerId,\n      tokenManagerTokenAccountId,\n      issuerTokenAccountId\n    )\n  );\n\n  //////////////////////////////\n  //////////// index ///////////\n  //////////////////////////////\n  if (receiptOptions) {\n    const { receiptMintKeypair } = receiptOptions;\n    transaction.add(\n      await tokenManager.instruction.claimReceiptMint(\n        connection,\n        wallet,\n        \"receipt\",\n        tokenManagerId,\n        receiptMintKeypair.publicKey\n      )\n    );\n  }\n\n  return [transaction, tokenManagerId, otp];\n};\n\n/**\n * Add claim instructions to a transaction\n * @param transaction\n * @param connection\n * @param wallet\n * @param tokenManagerId\n * @param otpKeypair\n * @returns Transaction with relevent claim instructions added\n */\nexport const withClaimToken = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  tokenManagerId: PublicKey,\n  additionalOptions?: {\n    otpKeypair?: Keypair | null;\n    payer?: PublicKey;\n  }\n): Promise<Transaction> => {\n  const [tokenManagerData, claimApproverData] = await Promise.all([\n    tokenManager.accounts.getTokenManager(connection, tokenManagerId),\n    tryGetAccount(() =>\n      claimApprover.accounts.getClaimApprover(connection, tokenManagerId)\n    ),\n  ]);\n\n  let claimReceiptId;\n  // pay claim approver\n  if (\n    claimApproverData &&\n    tokenManagerData.parsed.claimApprover &&\n    tokenManagerData.parsed.claimApprover.toString() ===\n      claimApproverData.pubkey.toString()\n  ) {\n    const payerTokenAccountId = await findAta(\n      claimApproverData.parsed.paymentMint,\n      wallet.publicKey\n    );\n\n    [claimReceiptId] = await tokenManager.pda.findClaimReceiptId(\n      tokenManagerId,\n      wallet.publicKey\n    );\n\n    const paymentAccounts = await withRemainingAccountsForPayment(\n      transaction,\n      connection,\n      wallet,\n      claimApproverData.parsed.paymentMint,\n      tokenManagerData.parsed.issuer,\n      claimApproverData.parsed.paymentManager,\n      tokenManagerData.parsed.receiptMint,\n      additionalOptions?.payer ?? wallet.publicKey\n    );\n\n    transaction.add(\n      await claimApprover.instruction.pay(\n        connection,\n        wallet,\n        tokenManagerId,\n        payerTokenAccountId,\n        claimApproverData.parsed.paymentManager,\n        paymentAccounts\n      )\n    );\n  } else if (tokenManagerData.parsed.claimApprover) {\n    if (\n      !additionalOptions?.otpKeypair ||\n      additionalOptions?.otpKeypair.publicKey.toString() !==\n        tokenManagerData.parsed.claimApprover.toString()\n    ) {\n      throw new Error(\"Invalid OTP\");\n    }\n    // approve claim request\n    const [createClaimReceiptIx, claimReceipt] =\n      await tokenManager.instruction.createClaimReceipt(\n        connection,\n        wallet,\n        tokenManagerId,\n        additionalOptions?.otpKeypair.publicKey,\n        additionalOptions?.payer\n      );\n    transaction.add(createClaimReceiptIx);\n    claimReceiptId = claimReceipt;\n  }\n\n  const tokenManagerTokenAccountId = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    tokenManagerData.parsed.mint,\n    tokenManagerId,\n    true\n  );\n\n  const recipientTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n    transaction,\n    connection,\n    tokenManagerData.parsed.mint,\n    wallet.publicKey,\n    additionalOptions?.payer ?? wallet.publicKey\n  );\n\n  // claim\n  transaction.add(\n    await tokenManager.instruction.claim(\n      connection,\n      wallet,\n      tokenManagerId,\n      tokenManagerData.parsed.kind,\n      tokenManagerData.parsed.mint,\n      tokenManagerTokenAccountId,\n      recipientTokenAccountId,\n      claimReceiptId\n    )\n  );\n\n  return transaction;\n};\n\nexport const withUnissueToken = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  mintId: PublicKey\n): Promise<Transaction> => {\n  const tokenManagerId = await tokenManagerAddressFromMint(connection, mintId);\n\n  const tokenManagerTokenAccountId = await findAta(\n    mintId,\n    tokenManagerId,\n    true\n  );\n\n  const issuerTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n    transaction,\n    connection,\n    mintId,\n    wallet.publicKey,\n    wallet.publicKey\n  );\n\n  return transaction.add(\n    tokenManager.instruction.unissue(\n      connection,\n      wallet,\n      tokenManagerId,\n      tokenManagerTokenAccountId,\n      issuerTokenAccountId\n    )\n  );\n};\n\nexport const withInvalidate = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  mintId: PublicKey,\n  UTCNow: number = Date.now() / 1000\n): Promise<Transaction> => {\n  const tokenManagerId = await tokenManagerAddressFromMint(connection, mintId);\n\n  const [[useInvalidatorId], [timeInvalidatorId]] = await Promise.all([\n    useInvalidator.pda.findUseInvalidatorAddress(tokenManagerId),\n    timeInvalidator.pda.findTimeInvalidatorAddress(tokenManagerId),\n  ]);\n\n  const [useInvalidatorData, timeInvalidatorData, tokenManagerData] =\n    await Promise.all([\n      tryGetAccount(() =>\n        useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId)\n      ),\n      tryGetAccount(() =>\n        timeInvalidator.accounts.getTimeInvalidator(\n          connection,\n          timeInvalidatorId\n        )\n      ),\n      tryGetAccount(() =>\n        tokenManager.accounts.getTokenManager(connection, tokenManagerId)\n      ),\n    ]);\n\n  if (!tokenManagerData) return transaction;\n\n  const tokenManagerTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n    transaction,\n    connection,\n    mintId,\n    tokenManagerId,\n    wallet.publicKey,\n    true\n  );\n\n  const remainingAccountsForReturn = await withRemainingAccountsForReturn(\n    transaction,\n    connection,\n    wallet,\n    tokenManagerData\n  );\n\n  if (\n    useInvalidatorData &&\n    useInvalidatorData.parsed.totalUsages &&\n    useInvalidatorData.parsed.usages.gte(useInvalidatorData.parsed.totalUsages)\n  ) {\n    transaction.add(\n      await useInvalidator.instruction.invalidate(\n        connection,\n        wallet,\n        mintId,\n        tokenManagerId,\n        tokenManagerData.parsed.kind,\n        tokenManagerData.parsed.state,\n        tokenManagerTokenAccountId,\n        tokenManagerData?.parsed.recipientTokenAccount,\n        remainingAccountsForReturn\n      )\n    );\n    transaction.add(\n      useInvalidator.instruction.close(\n        connection,\n        wallet,\n        useInvalidatorId,\n        tokenManagerId,\n        useInvalidatorData.parsed.collector\n      )\n    );\n  } else if (\n    timeInvalidatorData &&\n    shouldTimeInvalidate(tokenManagerData, timeInvalidatorData, UTCNow)\n  ) {\n    transaction.add(\n      await timeInvalidator.instruction.invalidate(\n        connection,\n        wallet,\n        mintId,\n        tokenManagerId,\n        tokenManagerData.parsed.kind,\n        tokenManagerData.parsed.state,\n        tokenManagerTokenAccountId,\n        tokenManagerData?.parsed.recipientTokenAccount,\n        remainingAccountsForReturn\n      )\n    );\n    transaction.add(\n      timeInvalidator.instruction.close(\n        connection,\n        wallet,\n        timeInvalidatorData.pubkey,\n        timeInvalidatorData.parsed.tokenManager,\n        timeInvalidatorData.parsed.collector\n      )\n    );\n  } else if (\n    tokenManagerData.parsed.invalidators.some((inv) =>\n      inv.equals(wallet.publicKey)\n    ) ||\n    tokenManagerData.parsed.invalidationType === InvalidationType.Return ||\n    tokenManagerData.parsed.invalidationType === InvalidationType.Reissue\n  ) {\n    transaction.add(\n      await tokenManager.instruction.invalidate(\n        connection,\n        wallet,\n        mintId,\n        tokenManagerId,\n        tokenManagerData.parsed.kind,\n        tokenManagerData.parsed.state,\n        tokenManagerTokenAccountId,\n        tokenManagerData?.parsed.recipientTokenAccount,\n        remainingAccountsForReturn\n      )\n    );\n  }\n  return transaction;\n};\n\nexport const withReturn = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  tokenManagerData: AccountData<TokenManagerData>\n): Promise<Transaction> => {\n  const tokenManagerTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n    transaction,\n    connection,\n    tokenManagerData.parsed.mint,\n    tokenManagerData.pubkey,\n    wallet.publicKey,\n    true\n  );\n  const remainingAccountsForReturn = await withRemainingAccountsForReturn(\n    transaction,\n    connection,\n    wallet,\n    tokenManagerData\n  );\n\n  transaction.add(\n    await tokenManager.instruction.invalidate(\n      connection,\n      wallet,\n      tokenManagerData.parsed.mint,\n      tokenManagerData.pubkey,\n      tokenManagerData.parsed.kind,\n      tokenManagerData.parsed.state,\n      tokenManagerTokenAccountId,\n      tokenManagerData?.parsed.recipientTokenAccount,\n      remainingAccountsForReturn\n    )\n  );\n  return transaction;\n};\n\nexport const withUse = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  mintId: PublicKey,\n  usages: number,\n  collector?: PublicKey\n): Promise<Transaction> => {\n  const tokenManagerId = await tokenManagerAddressFromMint(connection, mintId);\n\n  const [useInvalidatorId] = await useInvalidator.pda.findUseInvalidatorAddress(\n    tokenManagerId\n  );\n\n  const [useInvalidatorData, tokenManagerData] = await Promise.all([\n    tryGetAccount(() =>\n      useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId)\n    ),\n    tryGetAccount(() =>\n      tokenManager.accounts.getTokenManager(connection, tokenManagerId)\n    ),\n  ]);\n\n  if (!useInvalidatorData) {\n    // init\n    const [InitTx] = await useInvalidator.instruction.init(\n      connection,\n      wallet,\n      tokenManagerId,\n      { collector: collector }\n    );\n    transaction.add(InitTx);\n  }\n\n  if (!tokenManagerData?.parsed.recipientTokenAccount)\n    throw new Error(\"Token manager has not been claimed\");\n\n  // use\n  transaction.add(\n    await useInvalidator.instruction.incrementUsages(\n      connection,\n      wallet,\n      tokenManagerId,\n      tokenManagerData?.parsed.recipientTokenAccount,\n      usages\n    )\n  );\n\n  if (\n    useInvalidatorData?.parsed.totalUsages &&\n    useInvalidatorData?.parsed.usages\n      .add(new BN(usages))\n      .gte(useInvalidatorData?.parsed.totalUsages)\n  ) {\n    const tokenManagerTokenAccountId =\n      await withFindOrInitAssociatedTokenAccount(\n        transaction,\n        connection,\n        mintId,\n        tokenManagerId,\n        wallet.publicKey,\n        true\n      );\n\n    const remainingAccountsForReturn = await withRemainingAccountsForReturn(\n      transaction,\n      connection,\n      wallet,\n      tokenManagerData\n    );\n\n    transaction.add(\n      await useInvalidator.instruction.invalidate(\n        connection,\n        wallet,\n        mintId,\n        tokenManagerId,\n        tokenManagerData.parsed.kind,\n        tokenManagerData.parsed.state,\n        tokenManagerTokenAccountId,\n        tokenManagerData?.parsed.recipientTokenAccount,\n        remainingAccountsForReturn\n      )\n    );\n    transaction.add(\n      useInvalidator.instruction.close(\n        connection,\n        wallet,\n        useInvalidatorId,\n        tokenManagerId,\n        useInvalidatorData.parsed.collector\n      )\n    );\n  }\n  return transaction;\n};\n\nexport const withExtendExpiration = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  tokenManagerId: PublicKey,\n  secondsToAdd: number\n): Promise<Transaction> => {\n  const [timeInvalidatorId] =\n    await timeInvalidator.pda.findTimeInvalidatorAddress(tokenManagerId);\n  const [timeInvalidatorData, tokenManagerData] = await Promise.all([\n    timeInvalidator.accounts.getTimeInvalidator(connection, timeInvalidatorId),\n    tokenManager.accounts.getTokenManager(connection, tokenManagerId),\n  ]);\n\n  if (timeInvalidatorData && timeInvalidatorData.parsed.extensionPaymentMint) {\n    const payerTokenAccountId = await findAta(\n      timeInvalidatorData.parsed.extensionPaymentMint,\n      wallet.publicKey\n    );\n\n    const paymentAccounts = await withRemainingAccountsForPayment(\n      transaction,\n      connection,\n      wallet,\n      timeInvalidatorData.parsed.extensionPaymentMint,\n      tokenManagerData.parsed.issuer,\n      timeInvalidatorData.parsed.paymentManager,\n      tokenManagerData.parsed.receiptMint\n    );\n\n    transaction.add(\n      timeInvalidator.instruction.extendExpiration(\n        connection,\n        wallet,\n        tokenManagerId,\n        timeInvalidatorData.parsed.paymentManager,\n        payerTokenAccountId,\n        timeInvalidatorId,\n        secondsToAdd,\n        paymentAccounts\n      )\n    );\n  } else {\n    console.log(\"No payment mint\");\n  }\n\n  return transaction;\n};\n\nexport const withExtendUsages = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  tokenManagerId: PublicKey,\n  usagesToAdd: number\n): Promise<Transaction> => {\n  const [useInvalidatorId] = await useInvalidator.pda.findUseInvalidatorAddress(\n    tokenManagerId\n  );\n  const [useInvalidatorData, tokenManagerData] = await Promise.all([\n    useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId),\n    tokenManager.accounts.getTokenManager(connection, tokenManagerId),\n  ]);\n\n  if (useInvalidatorData && useInvalidatorData.parsed.extensionPaymentMint) {\n    const payerTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n      transaction,\n      connection,\n      useInvalidatorData.parsed.extensionPaymentMint,\n      wallet.publicKey,\n      wallet.publicKey\n    );\n\n    const paymentAccounts = await withRemainingAccountsForPayment(\n      transaction,\n      connection,\n      wallet,\n      useInvalidatorData.parsed.extensionPaymentMint,\n      tokenManagerData.parsed.issuer,\n      useInvalidatorData.parsed.paymentManager,\n      tokenManagerData.parsed.receiptMint\n    );\n\n    transaction.add(\n      useInvalidator.instruction.extendUsages(\n        connection,\n        wallet,\n        tokenManagerId,\n        useInvalidatorData.parsed.paymentManager,\n        payerTokenAccountId,\n        useInvalidatorId,\n        usagesToAdd,\n        paymentAccounts\n      )\n    );\n  }\n\n  return transaction;\n};\n\nexport const withResetExpiration = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  tokenManagerId: PublicKey\n): Promise<Transaction> => {\n  const [timeInvalidatorId] =\n    await timeInvalidator.pda.findTimeInvalidatorAddress(tokenManagerId);\n  const [tokenManagerData] = await Promise.all([\n    tokenManager.accounts.getTokenManager(connection, tokenManagerId),\n  ]);\n\n  if (tokenManagerData.parsed.state === TokenManagerState.Issued) {\n    transaction.add(\n      timeInvalidator.instruction.resetExpiration(\n        connection,\n        wallet,\n        tokenManagerId,\n        timeInvalidatorId\n      )\n    );\n  } else {\n    console.log(\"Token Manager not in state issued to reset expiration\");\n  }\n\n  return transaction;\n};\n"]}