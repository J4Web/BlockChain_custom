"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllTimeInvalidators = exports.getExpiredTimeInvalidators = exports.getTimeInvalidators = exports.getTimeInvalidator = void 0;
const anchor_1 = require("@project-serum/anchor");
const constants_1 = require("./constants");
// TODO fix types
const getTimeInvalidator = async (connection, timeInvalidatorId) => {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const timeInvalidatorProgram = new anchor_1.Program(constants_1.TIME_INVALIDATOR_IDL, constants_1.TIME_INVALIDATOR_ADDRESS, provider);
    const parsed = await timeInvalidatorProgram.account.timeInvalidator.fetch(timeInvalidatorId);
    return {
        parsed,
        pubkey: timeInvalidatorId,
    };
};
exports.getTimeInvalidator = getTimeInvalidator;
const getTimeInvalidators = async (connection, timeInvalidatorIds) => {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const timeInvalidatorProgram = new anchor_1.Program(constants_1.TIME_INVALIDATOR_IDL, constants_1.TIME_INVALIDATOR_ADDRESS, provider);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    let timeInvalidators = [];
    try {
        timeInvalidators =
            await timeInvalidatorProgram.account.timeInvalidator.fetchMultiple(timeInvalidatorIds);
    }
    catch (e) {
        console.log(e);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return timeInvalidators.map((tm, i) => ({
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        parsed: tm,
        pubkey: timeInvalidatorIds[i],
    }));
};
exports.getTimeInvalidators = getTimeInvalidators;
const getExpiredTimeInvalidators = async (connection) => {
    const programAccounts = await connection.getProgramAccounts(constants_1.TIME_INVALIDATOR_ADDRESS);
    const expiredTimeInvalidators = [];
    const coder = new anchor_1.BorshAccountsCoder(constants_1.TIME_INVALIDATOR_IDL);
    programAccounts.forEach((account) => {
        var _a;
        try {
            const timeInvalidatorData = coder.decode("timeInvalidator", account.account.data);
            if ((_a = timeInvalidatorData.expiration) === null || _a === void 0 ? void 0 : _a.lte(new anchor_1.BN(Date.now() / 1000))) {
                expiredTimeInvalidators.push({
                    ...account,
                    parsed: timeInvalidatorData,
                });
            }
        }
        catch (e) {
            console.log(`Failed to decode time invalidator data`);
        }
    });
    return expiredTimeInvalidators;
};
exports.getExpiredTimeInvalidators = getExpiredTimeInvalidators;
const getAllTimeInvalidators = async (connection) => {
    const programAccounts = await connection.getProgramAccounts(constants_1.TIME_INVALIDATOR_ADDRESS);
    const expiredTimeInvalidators = [];
    const coder = new anchor_1.BorshAccountsCoder(constants_1.TIME_INVALIDATOR_IDL);
    programAccounts.forEach((account) => {
        try {
            const timeInvalidatorData = coder.decode("timeInvalidator", account.account.data);
            expiredTimeInvalidators.push({
                ...account,
                parsed: timeInvalidatorData,
            });
        }
        catch (e) {
            console.log(`Failed to decode time invalidator data`);
        }
    });
    return expiredTimeInvalidators;
};
exports.getAllTimeInvalidators = getAllTimeInvalidators;
//# sourceMappingURL=accounts.js.map