"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.secondsToString = exports.capitalizeFirstLetter = exports.camelCase = exports.firstParam = exports.secondstoDuration = exports.longDateString = exports.shortDateString = exports.pubKeyUrl = exports.shortPubKey = exports.getExpirationString = exports.getQueryParam = exports.connectionFor = void 0;
const tslib_1 = require("tslib");
const web3 = tslib_1.__importStar(require("@solana/web3.js"));
const networkURLs = {
    ["mainnet-beta"]: "https://ssc-dao.genesysgo.net/",
    mainnet: "https://ssc-dao.genesysgo.net/",
    devnet: "https://psytrbhymqlkfrhudd.dev.genesysgo.net:8899/",
    testnet: "https://api.testnet.solana.com/",
    localnet: "http://localhost:8899/",
};
/**
 * Create and return new Connection object
 * @param cluster
 * @param defaultCluster
 * @returns
 */
const connectionFor = (cluster, defaultCluster = "mainnet") => {
    return new web3.Connection(process.env.RPC_URL || networkURLs[cluster || defaultCluster], "recent");
};
exports.connectionFor = connectionFor;
function getQueryParam(url, name) {
    if (!url || !name)
        return null;
    const q = url.match(new RegExp("[?&]" + name + "=([^&#]*)"));
    return q && q[1];
}
exports.getQueryParam = getQueryParam;
function getExpirationString(expiration, UTCSecondsNow) {
    let day = (expiration - UTCSecondsNow) / 60 / 60 / 24;
    let hour = ((expiration - UTCSecondsNow) / 60 / 60) % 24;
    let minute = ((expiration - UTCSecondsNow) / 60) % 60;
    let second = (expiration - UTCSecondsNow) % 60;
    const floorOrCeil = (n) => expiration - UTCSecondsNow > 0 ? Math.floor(n) : Math.ceil(n);
    day = day < 0 ? 0 : day;
    hour = hour < 0 ? 0 : hour;
    minute = minute < 0 ? 0 : minute;
    second = second < 0 ? 0 : second;
    return `${floorOrCeil(day) ? `${floorOrCeil(day)}d` : ""} ${floorOrCeil(hour) ? `${floorOrCeil(hour)}h` : ""} ${floorOrCeil(minute) ? `${floorOrCeil(minute)}m` : ""} ${floorOrCeil(second) ? `${floorOrCeil(second)}s` : ""}`;
}
exports.getExpirationString = getExpirationString;
function shortPubKey(pubkey) {
    if (!pubkey)
        return "";
    return `${pubkey === null || pubkey === void 0 ? void 0 : pubkey.toString().substring(0, 4)}..${pubkey === null || pubkey === void 0 ? void 0 : pubkey.toString().substring((pubkey === null || pubkey === void 0 ? void 0 : pubkey.toString().length) - 4)}`;
}
exports.shortPubKey = shortPubKey;
function pubKeyUrl(pubkey, cluster) {
    if (!pubkey)
        return "https://explorer.solana.com";
    return `https://explorer.solana.com/address/${pubkey.toString()}/metadata${cluster === "devnet" ? "?cluster=devnet" : ""}`;
}
exports.pubKeyUrl = pubKeyUrl;
function shortDateString(utc_seconds) {
    return `${new Date(utc_seconds * 1000).toLocaleDateString([], {
        month: "2-digit",
        day: "2-digit",
        year: "2-digit",
    })} ${new Date(utc_seconds * 1000).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
    })}`;
}
exports.shortDateString = shortDateString;
function longDateString(utcSeconds) {
    return new Date(utcSeconds * 1000).toLocaleTimeString(["en-US"], {
        year: "2-digit",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        timeZoneName: "short",
    });
}
exports.longDateString = longDateString;
function secondstoDuration(durationSeconds) {
    const years = Math.floor(durationSeconds / 31449600);
    const months = Math.floor((durationSeconds % 31449600) / 2419200);
    const weeks = Math.floor((durationSeconds % 2419200) / 604800);
    const days = Math.floor((durationSeconds % 604800) / 86400);
    const hours = Math.floor((durationSeconds % 86400) / 3600);
    const minutes = Math.floor((durationSeconds % 3600) / 60);
    const seconds = durationSeconds % 60;
    let duration = "";
    const optionalVals = [`${years}Y`, `${months}M`, `${weeks}w`, `${days}d`];
    const vals = [`${hours}h`, `${minutes}m`, `${seconds}s`];
    for (const val of optionalVals) {
        if (parseInt(val.substring(0, val.length - 1)) > 0) {
            duration += val + " ";
        }
    }
    for (const val of vals) {
        duration += val + " ";
    }
    return duration;
}
exports.secondstoDuration = secondstoDuration;
const firstParam = (param) => {
    if (!param)
        return "";
    return typeof param === "string" ? param : param[0] || "";
};
exports.firstParam = firstParam;
const camelCase = (str) => {
    return str
        .split(" ")
        .map((x) => x.charAt(0).toUpperCase() + x.slice(1))
        .join("");
};
exports.camelCase = camelCase;
const capitalizeFirstLetter = (value) => {
    return value[0] ? value[0].toUpperCase() + value.slice(1) : "";
};
exports.capitalizeFirstLetter = capitalizeFirstLetter;
const secondsToString = (requiredSeconds, showSeconds = true) => {
    if (!requiredSeconds || requiredSeconds <= 0)
        return "0";
    const weeks = Math.floor(requiredSeconds / 60 / 60 / 24 / 7);
    const days = Math.floor((requiredSeconds / 60 / 60 / 24) % 7);
    const hours = Math.floor((requiredSeconds / 60 / 60) % 24);
    const minutes = Math.floor((requiredSeconds / 60) % 60);
    const seconds = Math.round(requiredSeconds % 60);
    return `${weeks ? `${weeks}w ` : ""} ${days ? `${days}d ` : ""}${!weeks && hours ? `${hours}h ` : ""}${!weeks && minutes ? `${minutes}m ` : ""}${seconds && showSeconds ? `${seconds}s` : ""}`;
};
exports.secondsToString = secondsToString;
//# sourceMappingURL=utils.js.map