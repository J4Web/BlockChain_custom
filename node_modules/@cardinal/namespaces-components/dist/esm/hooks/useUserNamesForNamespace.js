import { __awaiter } from "tslib";
import { getBatchedMultipleAccounts } from '@cardinal/common';
import { findNamespaceId } from '@cardinal/namespaces';
import * as metaplex from '@metaplex-foundation/mpl-token-metadata';
import * as spl from '@solana/spl-token';
import { PublicKey } from '@solana/web3.js';
import { useQuery } from 'react-query';
import { accountDataById } from '../utils/accounts';
import { TWITTER_NAMESPACE_NAME } from '../utils/constants';
import { tryPublicKey } from '../utils/format';
export const useUserNamesForNamespace = (connection, walletId, namespaceName) => {
    return useQuery(['useUserNamesForNamespace', walletId === null || walletId === void 0 ? void 0 : walletId.toString()], () => __awaiter(void 0, void 0, void 0, function* () {
        if (!walletId)
            return [];
        const [namespaceId] = yield findNamespaceId(namespaceName);
        const allTokenAccounts = yield connection.getParsedTokenAccountsByOwner(new PublicKey(walletId), { programId: spl.TOKEN_PROGRAM_ID });
        let tokenAccounts = allTokenAccounts.value
            .filter((tokenAccount) => tokenAccount.account.data.parsed.info.tokenAmount.uiAmount > 0)
            .sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
        // lookup metaplex data
        const metaplexIds = yield Promise.all(tokenAccounts.map((tokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
            return (yield metaplex.MetadataProgram.findMetadataAccount(new PublicKey(tokenAccount.account.data.parsed.info.mint)))[0];
        })));
        const metaplexAccountInfos = yield getBatchedMultipleAccounts(connection, metaplexIds);
        const metaplexData = metaplexAccountInfos.reduce((acc, accountInfo, i) => {
            try {
                acc[tokenAccounts[i].pubkey.toString()] = Object.assign(Object.assign({ pubkey: metaplexIds[i] }, accountInfo), { parsed: metaplex.MetadataData.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data) });
            }
            catch (e) { }
            return acc;
        }, {});
        // filter by creators
        tokenAccounts = tokenAccounts.filter((tokenAccount) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            return ((_d = (_c = (_b = (_a = metaplexData[tokenAccount.pubkey.toString()]) === null || _a === void 0 ? void 0 : _a.parsed) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.creators) === null || _d === void 0 ? void 0 : _d.some((creator) => creator.address.toString() === namespaceId.toString() &&
                creator.verified)) ||
                (((_g = (_f = (_e = metaplexData[tokenAccount.pubkey.toString()]) === null || _e === void 0 ? void 0 : _e.parsed) === null || _f === void 0 ? void 0 : _f.data) === null || _g === void 0 ? void 0 : _g.symbol) === 'NAME' &&
                    ((_k = (_j = (_h = metaplexData[tokenAccount.pubkey.toString()]) === null || _h === void 0 ? void 0 : _h.parsed) === null || _j === void 0 ? void 0 : _j.data) === null || _k === void 0 ? void 0 : _k.name.includes(TWITTER_NAMESPACE_NAME)));
        });
        // lookup delegates
        const delegateIds = tokenAccounts.map((tokenAccount) => tryPublicKey(tokenAccount.account.data.parsed.info.delegate));
        const accountsById = yield accountDataById(connection, delegateIds);
        return tokenAccounts.map((tokenAccount, i) => {
            const delegateData = accountsById[tokenAccount.account.data.parsed.info.delegate];
            let tokenManagerData;
            let certificateData;
            if ((delegateData === null || delegateData === void 0 ? void 0 : delegateData.type) === 'tokenManager') {
                tokenManagerData = delegateData;
            }
            else if ((delegateData === null || delegateData === void 0 ? void 0 : delegateData.type) === 'certificate') {
                certificateData = delegateData;
            }
            return {
                tokenAccount,
                metaplexData: metaplexData[tokenAccount.pubkey.toString()],
                tokenManager: tokenManagerData,
                certificate: certificateData,
            };
        });
    }), {
        refetchOnMount: false,
        refetchOnWindowFocus: false,
    });
};
//# sourceMappingURL=useUserNamesForNamespace.js.map