import { __awaiter } from "tslib";
import { CERTIFICATE_IDL, CERTIFICATE_PROGRAM_ID } from '@cardinal/certificates';
import { getBatchedMultipleAccounts } from '@cardinal/common';
import { CLAIM_APPROVER_ADDRESS, CLAIM_APPROVER_IDL, } from '@cardinal/token-manager/dist/cjs/programs/claimApprover';
import { TIME_INVALIDATOR_ADDRESS, TIME_INVALIDATOR_IDL, } from '@cardinal/token-manager/dist/cjs/programs/timeInvalidator';
import { TOKEN_MANAGER_ADDRESS, TOKEN_MANAGER_IDL, } from '@cardinal/token-manager/dist/cjs/programs/tokenManager';
import { USE_INVALIDATOR_ADDRESS, USE_INVALIDATOR_IDL, } from '@cardinal/token-manager/dist/cjs/programs/useInvalidator';
import * as metaplex from '@metaplex-foundation/mpl-token-metadata';
import { EditionData, MasterEditionV2Data, MetadataKey, } from '@metaplex-foundation/mpl-token-metadata';
import { BorshAccountsCoder } from '@project-serum/anchor';
import * as spl from '@solana/spl-token';
export const deserializeAccountInfos = (accountIds, accountInfos) => {
    return accountInfos.reduce((acc, accountInfo, i) => {
        var _a, _b;
        const ownerString = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner.toString();
        switch (ownerString) {
            case CERTIFICATE_PROGRAM_ID.toString():
                try {
                    const type = 'certificate';
                    const coder = new BorshAccountsCoder(CERTIFICATE_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case TOKEN_MANAGER_ADDRESS.toString():
                try {
                    const type = 'tokenManager';
                    const coder = new BorshAccountsCoder(TOKEN_MANAGER_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case TIME_INVALIDATOR_ADDRESS.toString():
                try {
                    const type = 'timeInvalidator';
                    const coder = new BorshAccountsCoder(TIME_INVALIDATOR_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case USE_INVALIDATOR_ADDRESS.toString():
                try {
                    const type = 'useInvalidator';
                    const coder = new BorshAccountsCoder(USE_INVALIDATOR_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case CLAIM_APPROVER_ADDRESS.toString():
                try {
                    const type = 'paidClaimApprover';
                    const coder = new BorshAccountsCoder(CLAIM_APPROVER_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case spl.TOKEN_PROGRAM_ID.toString():
                const accountData = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data;
                acc[accountIds[i].toString()] =
                    accountData.space === spl.MintLayout.span
                        ? Object.assign(Object.assign({ type: 'mint' }, accountInfo), (_a = accountData.parsed) === null || _a === void 0 ? void 0 : _a.info) : Object.assign(Object.assign({ type: 'tokenAccount' }, accountInfo), (_b = accountData.parsed) === null || _b === void 0 ? void 0 : _b.info);
                return acc;
            case metaplex.MetadataProgram.PUBKEY.toString():
                try {
                    acc[accountIds[i].toString()] = Object.assign({ type: 'metaplexMetadata', pubkey: accountIds[i], parsed: metaplex.MetadataData.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data) }, accountInfo);
                }
                catch (e) { }
                try {
                    const key = accountInfo === null || accountInfo === void 0
                        ? void 0
                        : accountInfo.data[0];
                    let parsed;
                    if (key === MetadataKey.EditionV1) {
                        parsed = EditionData.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    }
                    else if (key === MetadataKey.MasterEditionV1 ||
                        key === MetadataKey.MasterEditionV2) {
                        parsed = MasterEditionV2Data.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    }
                    if (parsed) {
                        acc[accountIds[i].toString()] = Object.assign({ type: 'editionData', pubkey: accountIds[i], parsed }, accountInfo);
                    }
                }
                catch (e) { }
                return acc;
            default:
                return acc;
        }
    }, {});
};
export const accountDataById = (connection, ids) => __awaiter(void 0, void 0, void 0, function* () {
    const filteredIds = ids.filter((id) => id !== null);
    const accountInfos = yield getBatchedMultipleAccounts(connection, filteredIds, { encoding: 'jsonParsed' });
    return deserializeAccountInfos(filteredIds, accountInfos);
});
//# sourceMappingURL=accounts.js.map