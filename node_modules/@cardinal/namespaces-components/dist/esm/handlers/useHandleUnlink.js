import { __awaiter } from "tslib";
import { withRevokeCertificateV2 } from '@cardinal/certificates';
import { withInvalidateExpiredNameEntry, withInvalidateExpiredReverseEntry, } from '@cardinal/namespaces';
import * as namespaces from '@cardinal/namespaces';
import { PublicKey, sendAndConfirmRawTransaction, Transaction, } from '@solana/web3.js';
import { useMutation } from 'react-query';
import { nameFromMint } from '../components/NameManager';
export const useHandleUnlink = (connection, wallet, namespaceName, userTokenData) => {
    return useMutation(({ reverseNameEntryData, }) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c;
        const [namespaceId] = yield namespaces.findNamespaceId(namespaceName);
        const transaction = new Transaction();
        const entryMint = new PublicKey((_a = userTokenData.metaplexData) === null || _a === void 0 ? void 0 : _a.parsed.mint);
        const [, entryName] = nameFromMint((_b = userTokenData.metaplexData) === null || _b === void 0 ? void 0 : _b.parsed.data.name, (_c = userTokenData.metaplexData) === null || _c === void 0 ? void 0 : _c.parsed.data.uri);
        if (userTokenData.certificate) {
            yield withRevokeCertificateV2(connection, wallet, transaction, {
                certificateMint: entryMint,
                revokeRecipient: namespaceId,
            });
        }
        else if (userTokenData.tokenManager) {
            // invalidate token manager
        }
        if (reverseNameEntryData) {
            yield withInvalidateExpiredReverseEntry(transaction, connection, wallet, {
                namespaceName,
                mintId: entryMint,
                entryName: reverseNameEntryData.parsed.entryName,
                reverseEntryId: reverseNameEntryData.pubkey,
            });
        }
        yield withInvalidateExpiredNameEntry(transaction, connection, wallet, {
            namespaceName,
            mintId: entryMint,
            entryName,
        });
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        return sendAndConfirmRawTransaction(connection, transaction.serialize(), {
            skipPreflight: true,
        });
    }));
};
//# sourceMappingURL=useHandleUnlink.js.map