"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNameEntryData = exports.getNameEntryData = void 0;
const tslib_1 = require("tslib");
const certificates_1 = require("@cardinal/certificates");
const common_1 = require("@cardinal/common");
const namespaces_1 = require("@cardinal/namespaces");
const metaplex = tslib_1.__importStar(require("@metaplex-foundation/mpl-token-metadata"));
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const splToken = tslib_1.__importStar(require("@solana/spl-token"));
const web3_js_1 = require("@solana/web3.js");
const react_query_1 = require("react-query");
function getNameEntryData(connection, namespaceName, entryName) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const nameEntry = yield (0, namespaces_1.getNameEntry)(connection, namespaceName, entryName);
        const { mint } = nameEntry.parsed;
        const [[metaplexId], [certificateId]] = yield Promise.all([
            metaplex.MetadataProgram.findMetadataAccount(new web3_js_1.PublicKey(mint)),
            (0, certificates_1.certificateIdForMint)(mint),
        ]);
        const [metaplexData, certificate] = yield Promise.all([
            metaplex.Metadata.load(connection, metaplexId),
            (0, common_1.tryGetAccount)(() => (0, certificates_1.getCertificate)(connection, certificateId)),
        ]);
        let json;
        try {
            json =
                metaplexData.data.data.uri &&
                    (yield fetch(metaplexData.data.data.uri).then((r) => r.json()));
        }
        catch (e) {
            console.log('Failed to get json', json);
        }
        const largestHolders = yield connection.getTokenLargestAccounts(mint);
        const certificateMintToken = new splToken.Token(connection, mint, splToken.TOKEN_PROGRAM_ID, 
        // not used
        anchor.web3.Keypair.generate());
        const largestTokenAccount = ((_a = largestHolders === null || largestHolders === void 0 ? void 0 : largestHolders.value[0]) === null || _a === void 0 ? void 0 : _a.address) &&
            (yield certificateMintToken.getAccountInfo((_b = largestHolders === null || largestHolders === void 0 ? void 0 : largestHolders.value[0]) === null || _b === void 0 ? void 0 : _b.address));
        let isOwnerPDA = false;
        if (largestTokenAccount === null || largestTokenAccount === void 0 ? void 0 : largestTokenAccount.owner) {
            const ownerAccountInfo = yield connection.getAccountInfo(largestTokenAccount === null || largestTokenAccount === void 0 ? void 0 : largestTokenAccount.owner);
            isOwnerPDA =
                (ownerAccountInfo === null || ownerAccountInfo === void 0 ? void 0 : ownerAccountInfo.owner.toString()) === namespaces_1.NAMESPACES_PROGRAM_ID.toString();
        }
        return {
            nameEntry,
            certificate: certificate !== null && certificate !== void 0 ? certificate : undefined,
            metaplexData: { pubkey: metaplexData.pubkey, parsed: metaplexData.data },
            arweaveData: { pubkey: metaplexId, parsed: json },
            largestHolders: largestHolders.value,
            owner: largestTokenAccount === null || largestTokenAccount === void 0 ? void 0 : largestTokenAccount.owner,
            isOwnerPDA,
        };
    });
}
exports.getNameEntryData = getNameEntryData;
const useNameEntryData = (connection, namespaceName, entryName) => {
    return (0, react_query_1.useQuery)(['useNameEntryData', namespaceName, entryName], () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (!entryName || !connection)
            return;
        return getNameEntryData(connection, namespaceName, entryName);
    }), {
        enabled: !!entryName && !!connection,
        refetchOnMount: false,
        refetchOnWindowFocus: false,
    });
};
exports.useNameEntryData = useNameEntryData;
//# sourceMappingURL=useNameEntryData.js.map