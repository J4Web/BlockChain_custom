"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useUserNamesForNamespace = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@cardinal/common");
const namespaces_1 = require("@cardinal/namespaces");
const metaplex = tslib_1.__importStar(require("@metaplex-foundation/mpl-token-metadata"));
const spl = tslib_1.__importStar(require("@solana/spl-token"));
const web3_js_1 = require("@solana/web3.js");
const react_query_1 = require("react-query");
const accounts_1 = require("../utils/accounts");
const constants_1 = require("../utils/constants");
const format_1 = require("../utils/format");
const useUserNamesForNamespace = (connection, walletId, namespaceName) => {
    return (0, react_query_1.useQuery)(['useUserNamesForNamespace', walletId === null || walletId === void 0 ? void 0 : walletId.toString()], () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (!walletId)
            return [];
        const [namespaceId] = yield (0, namespaces_1.findNamespaceId)(namespaceName);
        const allTokenAccounts = yield connection.getParsedTokenAccountsByOwner(new web3_js_1.PublicKey(walletId), { programId: spl.TOKEN_PROGRAM_ID });
        let tokenAccounts = allTokenAccounts.value
            .filter((tokenAccount) => tokenAccount.account.data.parsed.info.tokenAmount.uiAmount > 0)
            .sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
        // lookup metaplex data
        const metaplexIds = yield Promise.all(tokenAccounts.map((tokenAccount) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return (yield metaplex.MetadataProgram.findMetadataAccount(new web3_js_1.PublicKey(tokenAccount.account.data.parsed.info.mint)))[0];
        })));
        const metaplexAccountInfos = yield (0, common_1.getBatchedMultipleAccounts)(connection, metaplexIds);
        const metaplexData = metaplexAccountInfos.reduce((acc, accountInfo, i) => {
            try {
                acc[tokenAccounts[i].pubkey.toString()] = Object.assign(Object.assign({ pubkey: metaplexIds[i] }, accountInfo), { parsed: metaplex.MetadataData.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data) });
            }
            catch (e) { }
            return acc;
        }, {});
        // filter by creators
        tokenAccounts = tokenAccounts.filter((tokenAccount) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            return ((_d = (_c = (_b = (_a = metaplexData[tokenAccount.pubkey.toString()]) === null || _a === void 0 ? void 0 : _a.parsed) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.creators) === null || _d === void 0 ? void 0 : _d.some((creator) => creator.address.toString() === namespaceId.toString() &&
                creator.verified)) ||
                (((_g = (_f = (_e = metaplexData[tokenAccount.pubkey.toString()]) === null || _e === void 0 ? void 0 : _e.parsed) === null || _f === void 0 ? void 0 : _f.data) === null || _g === void 0 ? void 0 : _g.symbol) === 'NAME' &&
                    ((_k = (_j = (_h = metaplexData[tokenAccount.pubkey.toString()]) === null || _h === void 0 ? void 0 : _h.parsed) === null || _j === void 0 ? void 0 : _j.data) === null || _k === void 0 ? void 0 : _k.name.includes(constants_1.TWITTER_NAMESPACE_NAME)));
        });
        // lookup delegates
        const delegateIds = tokenAccounts.map((tokenAccount) => (0, format_1.tryPublicKey)(tokenAccount.account.data.parsed.info.delegate));
        const accountsById = yield (0, accounts_1.accountDataById)(connection, delegateIds);
        return tokenAccounts.map((tokenAccount, i) => {
            const delegateData = accountsById[tokenAccount.account.data.parsed.info.delegate];
            let tokenManagerData;
            let certificateData;
            if ((delegateData === null || delegateData === void 0 ? void 0 : delegateData.type) === 'tokenManager') {
                tokenManagerData = delegateData;
            }
            else if ((delegateData === null || delegateData === void 0 ? void 0 : delegateData.type) === 'certificate') {
                certificateData = delegateData;
            }
            return {
                tokenAccount,
                metaplexData: metaplexData[tokenAccount.pubkey.toString()],
                tokenManager: tokenManagerData,
                certificate: certificateData,
            };
        });
    }), {
        refetchOnMount: false,
        refetchOnWindowFocus: false,
    });
};
exports.useUserNamesForNamespace = useUserNamesForNamespace;
//# sourceMappingURL=useUserNamesForNamespace.js.map