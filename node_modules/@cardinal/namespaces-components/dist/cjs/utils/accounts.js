"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountDataById = exports.deserializeAccountInfos = void 0;
const tslib_1 = require("tslib");
const certificates_1 = require("@cardinal/certificates");
const common_1 = require("@cardinal/common");
const claimApprover_1 = require("@cardinal/token-manager/dist/cjs/programs/claimApprover");
const timeInvalidator_1 = require("@cardinal/token-manager/dist/cjs/programs/timeInvalidator");
const tokenManager_1 = require("@cardinal/token-manager/dist/cjs/programs/tokenManager");
const useInvalidator_1 = require("@cardinal/token-manager/dist/cjs/programs/useInvalidator");
const metaplex = tslib_1.__importStar(require("@metaplex-foundation/mpl-token-metadata"));
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const anchor_1 = require("@project-serum/anchor");
const spl = tslib_1.__importStar(require("@solana/spl-token"));
const deserializeAccountInfos = (accountIds, accountInfos) => {
    return accountInfos.reduce((acc, accountInfo, i) => {
        var _a, _b;
        const ownerString = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner.toString();
        switch (ownerString) {
            case certificates_1.CERTIFICATE_PROGRAM_ID.toString():
                try {
                    const type = 'certificate';
                    const coder = new anchor_1.BorshAccountsCoder(certificates_1.CERTIFICATE_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case tokenManager_1.TOKEN_MANAGER_ADDRESS.toString():
                try {
                    const type = 'tokenManager';
                    const coder = new anchor_1.BorshAccountsCoder(tokenManager_1.TOKEN_MANAGER_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case timeInvalidator_1.TIME_INVALIDATOR_ADDRESS.toString():
                try {
                    const type = 'timeInvalidator';
                    const coder = new anchor_1.BorshAccountsCoder(timeInvalidator_1.TIME_INVALIDATOR_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case useInvalidator_1.USE_INVALIDATOR_ADDRESS.toString():
                try {
                    const type = 'useInvalidator';
                    const coder = new anchor_1.BorshAccountsCoder(useInvalidator_1.USE_INVALIDATOR_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case claimApprover_1.CLAIM_APPROVER_ADDRESS.toString():
                try {
                    const type = 'paidClaimApprover';
                    const coder = new anchor_1.BorshAccountsCoder(claimApprover_1.CLAIM_APPROVER_IDL);
                    const parsed = coder.decode(type, accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    acc[accountIds[i].toString()] = Object.assign(Object.assign({ type, pubkey: accountIds[i] }, accountInfo), { parsed });
                }
                catch (e) { }
                return acc;
            case spl.TOKEN_PROGRAM_ID.toString():
                const accountData = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data;
                acc[accountIds[i].toString()] =
                    accountData.space === spl.MintLayout.span
                        ? Object.assign(Object.assign({ type: 'mint' }, accountInfo), (_a = accountData.parsed) === null || _a === void 0 ? void 0 : _a.info) : Object.assign(Object.assign({ type: 'tokenAccount' }, accountInfo), (_b = accountData.parsed) === null || _b === void 0 ? void 0 : _b.info);
                return acc;
            case metaplex.MetadataProgram.PUBKEY.toString():
                try {
                    acc[accountIds[i].toString()] = Object.assign({ type: 'metaplexMetadata', pubkey: accountIds[i], parsed: metaplex.MetadataData.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data) }, accountInfo);
                }
                catch (e) { }
                try {
                    const key = accountInfo === null || accountInfo === void 0
                        ? void 0
                        : accountInfo.data[0];
                    let parsed;
                    if (key === mpl_token_metadata_1.MetadataKey.EditionV1) {
                        parsed = mpl_token_metadata_1.EditionData.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    }
                    else if (key === mpl_token_metadata_1.MetadataKey.MasterEditionV1 ||
                        key === mpl_token_metadata_1.MetadataKey.MasterEditionV2) {
                        parsed = mpl_token_metadata_1.MasterEditionV2Data.deserialize(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                    }
                    if (parsed) {
                        acc[accountIds[i].toString()] = Object.assign({ type: 'editionData', pubkey: accountIds[i], parsed }, accountInfo);
                    }
                }
                catch (e) { }
                return acc;
            default:
                return acc;
        }
    }, {});
};
exports.deserializeAccountInfos = deserializeAccountInfos;
const accountDataById = (connection, ids) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const filteredIds = ids.filter((id) => id !== null);
    const accountInfos = yield (0, common_1.getBatchedMultipleAccounts)(connection, filteredIds, { encoding: 'jsonParsed' });
    return (0, exports.deserializeAccountInfos)(filteredIds, accountInfos);
});
exports.accountDataById = accountDataById;
//# sourceMappingURL=accounts.js.map