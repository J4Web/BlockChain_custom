"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useHandleUnlink = void 0;
const tslib_1 = require("tslib");
const certificates_1 = require("@cardinal/certificates");
const namespaces_1 = require("@cardinal/namespaces");
const namespaces = tslib_1.__importStar(require("@cardinal/namespaces"));
const web3_js_1 = require("@solana/web3.js");
const react_query_1 = require("react-query");
const NameManager_1 = require("../components/NameManager");
const useHandleUnlink = (connection, wallet, namespaceName, userTokenData) => {
    return (0, react_query_1.useMutation)(({ reverseNameEntryData, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c;
        const [namespaceId] = yield namespaces.findNamespaceId(namespaceName);
        const transaction = new web3_js_1.Transaction();
        const entryMint = new web3_js_1.PublicKey((_a = userTokenData.metaplexData) === null || _a === void 0 ? void 0 : _a.parsed.mint);
        const [, entryName] = (0, NameManager_1.nameFromMint)((_b = userTokenData.metaplexData) === null || _b === void 0 ? void 0 : _b.parsed.data.name, (_c = userTokenData.metaplexData) === null || _c === void 0 ? void 0 : _c.parsed.data.uri);
        if (userTokenData.certificate) {
            yield (0, certificates_1.withRevokeCertificateV2)(connection, wallet, transaction, {
                certificateMint: entryMint,
                revokeRecipient: namespaceId,
            });
        }
        else if (userTokenData.tokenManager) {
            // invalidate token manager
        }
        if (reverseNameEntryData) {
            yield (0, namespaces_1.withInvalidateExpiredReverseEntry)(transaction, connection, wallet, {
                namespaceName,
                mintId: entryMint,
                entryName: reverseNameEntryData.parsed.entryName,
                reverseEntryId: reverseNameEntryData.pubkey,
            });
        }
        yield (0, namespaces_1.withInvalidateExpiredNameEntry)(transaction, connection, wallet, {
            namespaceName,
            mintId: entryMint,
            entryName,
        });
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        return (0, web3_js_1.sendAndConfirmRawTransaction)(connection, transaction.serialize(), {
            skipPreflight: true,
        });
    }));
};
exports.useHandleUnlink = useHandleUnlink;
//# sourceMappingURL=useHandleUnlink.js.map