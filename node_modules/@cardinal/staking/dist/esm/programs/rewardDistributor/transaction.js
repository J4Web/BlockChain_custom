import { __awaiter } from "tslib";
import { findAta, tryGetAccount, withFindOrInitAssociatedTokenAccount, } from "@cardinal/common";
import { BN } from "@project-serum/anchor";
import { getRewardDistributor, getRewardEntry } from "./accounts";
import { RewardDistributorKind } from "./constants";
import { claimRewards, closeRewardDistributor, closeRewardEntry, initRewardDistributor, initRewardEntry, reclaimFunds, updateRewardDistributor, updateRewardEntry, } from "./instruction";
import { findRewardDistributorId, findRewardEntryId } from "./pda";
import { withRemainingAccountsForKind } from "./utils";
export const withInitRewardDistributor = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield findRewardDistributorId(params.stakePoolId);
    const remainingAccountsForKind = yield withRemainingAccountsForKind(transaction, connection, wallet, rewardDistributorId, params.kind || RewardDistributorKind.Mint, params.rewardMintId);
    transaction.add(initRewardDistributor(connection, wallet, {
        rewardDistributorId,
        stakePoolId: params.stakePoolId,
        rewardMintId: params.rewardMintId,
        rewardAmount: params.rewardAmount || new BN(1),
        rewardDurationSeconds: params.rewardDurationSeconds || new BN(1),
        kind: params.kind || RewardDistributorKind.Mint,
        remainingAccountsForKind,
        maxSupply: params.maxSupply,
        supply: params.supply,
        defaultMultiplier: params.defaultMultiplier,
        multiplierDecimals: params.multiplierDecimals,
    }));
    return [transaction, rewardDistributorId];
});
export const withInitRewardEntry = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardEntryId] = yield findRewardEntryId(params.rewardDistributorId, params.stakeEntryId);
    transaction.add(initRewardEntry(connection, wallet, {
        stakeEntryId: params.stakeEntryId,
        rewardDistributor: params.rewardDistributorId,
        rewardEntryId: rewardEntryId,
    }));
    return [transaction, rewardEntryId];
});
export const withClaimRewards = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield findRewardDistributorId(params.stakePoolId);
    const rewardDistributorData = yield tryGetAccount(() => getRewardDistributor(connection, rewardDistributorId));
    if (rewardDistributorData) {
        const rewardMintTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, rewardDistributorData.parsed.rewardMint, wallet.publicKey, wallet.publicKey);
        const remainingAccountsForKind = yield withRemainingAccountsForKind(transaction, connection, wallet, rewardDistributorId, rewardDistributorData.parsed.kind, rewardDistributorData.parsed.rewardMint);
        const [rewardEntryId] = yield findRewardEntryId(rewardDistributorData.pubkey, params.stakeEntryId);
        const rewardEntryData = yield tryGetAccount(() => getRewardEntry(connection, rewardEntryId));
        if (!rewardEntryData) {
            transaction.add(initRewardEntry(connection, wallet, {
                stakeEntryId: params.stakeEntryId,
                rewardDistributor: rewardDistributorData.pubkey,
                rewardEntryId: rewardEntryId,
            }));
        }
        transaction.add(yield claimRewards(connection, wallet, {
            stakePoolId: params.stakePoolId,
            stakeEntryId: params.stakeEntryId,
            rewardMintId: rewardDistributorData.parsed.rewardMint,
            rewardMintTokenAccountId: rewardMintTokenAccountId,
            remainingAccountsForKind,
        }));
    }
    return transaction;
});
export const withCloseRewardDistributor = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield findRewardDistributorId(params.stakePoolId);
    const rewardDistributorData = yield tryGetAccount(() => getRewardDistributor(connection, rewardDistributorId));
    if (rewardDistributorData) {
        const remainingAccountsForKind = yield withRemainingAccountsForKind(transaction, connection, wallet, rewardDistributorId, rewardDistributorData.parsed.kind, rewardDistributorData.parsed.rewardMint);
        transaction.add(yield closeRewardDistributor(connection, wallet, {
            stakePoolId: params.stakePoolId,
            rewardMintId: rewardDistributorData.parsed.rewardMint,
            remainingAccountsForKind,
        }));
    }
    return transaction;
});
export const withUpdateRewardEntry = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    return transaction.add(yield updateRewardEntry(connection, wallet, {
        stakePoolId: params.stakePoolId,
        stakeEntryId: params.stakeEntryId,
        multiplier: params.multiplier,
    }));
});
export const withCloseRewardEntry = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield findRewardDistributorId(params.stakePoolId);
    const [rewardEntryId] = yield findRewardEntryId(rewardDistributorId, params.stakeEntryId);
    return transaction.add(closeRewardEntry(connection, wallet, {
        rewardDistributorId: rewardDistributorId,
        rewardEntryId: rewardEntryId,
    }));
});
export const withUpdateRewardDistributor = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield findRewardDistributorId(params.stakePoolId);
    return transaction.add(updateRewardDistributor(connection, wallet, {
        rewardDistributorId: rewardDistributorId,
        defaultMultiplier: params.defaultMultiplier || new BN(1),
        multiplierDecimals: params.multiplierDecimals || 0,
        rewardAmount: params.rewardAmount || new BN(0),
        rewardDurationSeconds: params.rewardDurationSeconds || new BN(0),
    }));
});
export const withReclaimFunds = (transaction, connection, wallet, params) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield findRewardDistributorId(params.stakePoolId);
    const rewardDistributorData = yield tryGetAccount(() => getRewardDistributor(connection, rewardDistributorId));
    if (!rewardDistributorData) {
        throw new Error("No reward distrbutor found");
    }
    const rewardDistributorTokenAccountId = yield findAta(rewardDistributorData.parsed.rewardMint, rewardDistributorData.pubkey, true);
    const authorityTokenAccountId = yield findAta(rewardDistributorData.parsed.rewardMint, wallet.publicKey, true);
    return transaction.add(reclaimFunds(connection, wallet, {
        rewardDistributorId: rewardDistributorId,
        rewardDistributorTokenAccountId: rewardDistributorTokenAccountId,
        authorityTokenAccountId: authorityTokenAccountId,
        authority: wallet.publicKey,
        amount: params.amount,
    }));
});
//# sourceMappingURL=transaction.js.map