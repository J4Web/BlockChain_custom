import { __awaiter } from "tslib";
import { AnchorProvider, BorshAccountsCoder, Program, utils, } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";
import { STAKE_POOL_ADDRESS, STAKE_POOL_IDL } from ".";
import { AUTHORITY_OFFSET, POOL_OFFSET, STAKER_OFFSET } from "./constants";
import { findIdentifierId } from "./pda";
export const getStakePool = (connection, stakePoolId) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const parsed = yield stakePoolProgram.account.stakePool.fetch(stakePoolId);
    return {
        parsed,
        pubkey: stakePoolId,
    };
});
export const getStakePools = (connection, stakePoolIds) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const stakePools = (yield stakePoolProgram.account.stakePool.fetchMultiple(stakePoolIds));
    return stakePools.map((tm, i) => ({
        parsed: tm,
        pubkey: stakePoolIds[i],
    }));
});
export const getAllStakePools = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: utils.bytes.bs58.encode(BorshAccountsCoder.accountDiscriminator("stakePool")),
                },
            },
        ],
    });
    const stakePoolDatas = [];
    const coder = new BorshAccountsCoder(STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakePoolData = coder.decode("stakePool", account.account.data);
            if (stakePoolData) {
                stakePoolDatas.push(Object.assign(Object.assign({}, account), { parsed: stakePoolData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakePoolDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
export const getStakeEntriesForUser = (connection, user) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(STAKE_POOL_ADDRESS, {
        filters: [{ memcmp: { offset: STAKER_OFFSET, bytes: user.toBase58() } }],
    });
    const stakeEntryDatas = [];
    const coder = new BorshAccountsCoder(STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
        }
        catch (e) {
            console.log(`Failed to decode token manager data`);
        }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
export const getAllActiveStakeEntries = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: utils.bytes.bs58.encode(BorshAccountsCoder.accountDiscriminator("stakeEntry")),
                },
            },
        ],
    });
    const stakeEntryDatas = [];
    const coder = new BorshAccountsCoder(STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData &&
                stakeEntryData.lastStaker.toString() !== PublicKey.default.toString()) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
        }
        catch (e) {
            // console.log(`Failed to decode stake entry data`);
        }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
export const getActiveStakeEntriesForPool = (connection, stakePoolId) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: { offset: POOL_OFFSET, bytes: stakePoolId.toBase58() },
            },
        ],
    });
    const stakeEntryDatas = [];
    const coder = new BorshAccountsCoder(STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData &&
                stakeEntryData.lastStaker.toString() !== PublicKey.default.toString()) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
        }
        catch (e) {
            // console.log(`Failed to decode token manager data`);
        }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
export const getStakeEntry = (connection, stakeEntryId) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const parsed = yield stakePoolProgram.account.stakeEntry.fetch(stakeEntryId);
    return {
        parsed,
        pubkey: stakeEntryId,
    };
});
export const getStakeEntries = (connection, stakeEntryIds) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const stakeEntries = (yield stakePoolProgram.account.stakeEntry.fetchMultiple(stakeEntryIds));
    return stakeEntries.map((tm, i) => ({
        parsed: tm,
        pubkey: stakeEntryIds[i],
    }));
});
export const getPoolIdentifier = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const [identifierId] = yield findIdentifierId();
    const parsed = yield stakePoolProgram.account.identifier.fetch(identifierId);
    return {
        parsed,
        pubkey: identifierId,
    };
});
export const getStakeAuthorization = (connection, stakeAuthorizationId) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const parsed = yield stakePoolProgram.account.stakeAuthorizationRecord.fetch(stakeAuthorizationId);
    return {
        parsed,
        pubkey: stakeAuthorizationId,
    };
});
export const getStakeAuthorizations = (connection, stakeAuthorizationIds) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const stakePoolProgram = new Program(STAKE_POOL_IDL, STAKE_POOL_ADDRESS, provider);
    const stakeAuthorizations = (yield stakePoolProgram.account.stakeAuthorizationRecord.fetchMultiple(stakeAuthorizationIds));
    return stakeAuthorizations.map((data, i) => ({
        parsed: data,
        pubkey: stakeAuthorizationIds[i],
    }));
});
export const getStakeAuthorizationsForPool = (connection, poolId) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: utils.bytes.bs58.encode(BorshAccountsCoder.accountDiscriminator("stakeAuthorizationRecord")),
                },
            },
            {
                memcmp: { offset: POOL_OFFSET, bytes: poolId.toBase58() },
            },
        ],
    });
    const stakeAuthorizationDatas = [];
    const coder = new BorshAccountsCoder(STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const data = coder.decode("stakeAuthorizationRecord", account.account.data);
            stakeAuthorizationDatas.push(Object.assign(Object.assign({}, account), { parsed: data }));
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakeAuthorizationDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
export const getStakePoolsByAuthority = (connection, user) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: utils.bytes.bs58.encode(BorshAccountsCoder.accountDiscriminator("stakePool")),
                },
            },
            {
                memcmp: {
                    offset: AUTHORITY_OFFSET,
                    bytes: user.toBase58(),
                },
            },
        ],
    });
    const stakePoolDatas = [];
    const coder = new BorshAccountsCoder(STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakePoolData = coder.decode("stakePool", account.account.data);
            if (stakePoolData) {
                stakePoolDatas.push(Object.assign(Object.assign({}, account), { parsed: stakePoolData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakePoolDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
export const getAllStakeEntries = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(STAKE_POOL_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: utils.bytes.bs58.encode(BorshAccountsCoder.accountDiscriminator("stakeEntry")),
                },
            },
        ],
    });
    const stakeEntryDatas = [];
    const coder = new BorshAccountsCoder(STAKE_POOL_IDL);
    programAccounts.forEach((account) => {
        try {
            const stakeEntryData = coder.decode("stakeEntry", account.account.data);
            if (stakeEntryData) {
                stakeEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: stakeEntryData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return stakeEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
//# sourceMappingURL=accounts.js.map