"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withReclaimFunds = exports.withUpdateRewardDistributor = exports.withCloseRewardEntry = exports.withUpdateRewardEntry = exports.withCloseRewardDistributor = exports.withClaimRewards = exports.withInitRewardEntry = exports.withInitRewardDistributor = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@cardinal/common");
const anchor_1 = require("@project-serum/anchor");
const accounts_1 = require("./accounts");
const constants_1 = require("./constants");
const instruction_1 = require("./instruction");
const pda_1 = require("./pda");
const utils_1 = require("./utils");
const withInitRewardDistributor = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield (0, pda_1.findRewardDistributorId)(params.stakePoolId);
    const remainingAccountsForKind = yield (0, utils_1.withRemainingAccountsForKind)(transaction, connection, wallet, rewardDistributorId, params.kind || constants_1.RewardDistributorKind.Mint, params.rewardMintId);
    transaction.add((0, instruction_1.initRewardDistributor)(connection, wallet, {
        rewardDistributorId,
        stakePoolId: params.stakePoolId,
        rewardMintId: params.rewardMintId,
        rewardAmount: params.rewardAmount || new anchor_1.BN(1),
        rewardDurationSeconds: params.rewardDurationSeconds || new anchor_1.BN(1),
        kind: params.kind || constants_1.RewardDistributorKind.Mint,
        remainingAccountsForKind,
        maxSupply: params.maxSupply,
        supply: params.supply,
        defaultMultiplier: params.defaultMultiplier,
        multiplierDecimals: params.multiplierDecimals,
    }));
    return [transaction, rewardDistributorId];
});
exports.withInitRewardDistributor = withInitRewardDistributor;
const withInitRewardEntry = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [rewardEntryId] = yield (0, pda_1.findRewardEntryId)(params.rewardDistributorId, params.stakeEntryId);
    transaction.add((0, instruction_1.initRewardEntry)(connection, wallet, {
        stakeEntryId: params.stakeEntryId,
        rewardDistributor: params.rewardDistributorId,
        rewardEntryId: rewardEntryId,
    }));
    return [transaction, rewardEntryId];
});
exports.withInitRewardEntry = withInitRewardEntry;
const withClaimRewards = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield (0, pda_1.findRewardDistributorId)(params.stakePoolId);
    const rewardDistributorData = yield (0, common_1.tryGetAccount)(() => (0, accounts_1.getRewardDistributor)(connection, rewardDistributorId));
    if (rewardDistributorData) {
        const rewardMintTokenAccountId = yield (0, common_1.withFindOrInitAssociatedTokenAccount)(transaction, connection, rewardDistributorData.parsed.rewardMint, wallet.publicKey, wallet.publicKey);
        const remainingAccountsForKind = yield (0, utils_1.withRemainingAccountsForKind)(transaction, connection, wallet, rewardDistributorId, rewardDistributorData.parsed.kind, rewardDistributorData.parsed.rewardMint);
        const [rewardEntryId] = yield (0, pda_1.findRewardEntryId)(rewardDistributorData.pubkey, params.stakeEntryId);
        const rewardEntryData = yield (0, common_1.tryGetAccount)(() => (0, accounts_1.getRewardEntry)(connection, rewardEntryId));
        if (!rewardEntryData) {
            transaction.add((0, instruction_1.initRewardEntry)(connection, wallet, {
                stakeEntryId: params.stakeEntryId,
                rewardDistributor: rewardDistributorData.pubkey,
                rewardEntryId: rewardEntryId,
            }));
        }
        transaction.add(yield (0, instruction_1.claimRewards)(connection, wallet, {
            stakePoolId: params.stakePoolId,
            stakeEntryId: params.stakeEntryId,
            rewardMintId: rewardDistributorData.parsed.rewardMint,
            rewardMintTokenAccountId: rewardMintTokenAccountId,
            remainingAccountsForKind,
        }));
    }
    return transaction;
});
exports.withClaimRewards = withClaimRewards;
const withCloseRewardDistributor = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield (0, pda_1.findRewardDistributorId)(params.stakePoolId);
    const rewardDistributorData = yield (0, common_1.tryGetAccount)(() => (0, accounts_1.getRewardDistributor)(connection, rewardDistributorId));
    if (rewardDistributorData) {
        const remainingAccountsForKind = yield (0, utils_1.withRemainingAccountsForKind)(transaction, connection, wallet, rewardDistributorId, rewardDistributorData.parsed.kind, rewardDistributorData.parsed.rewardMint);
        transaction.add(yield (0, instruction_1.closeRewardDistributor)(connection, wallet, {
            stakePoolId: params.stakePoolId,
            rewardMintId: rewardDistributorData.parsed.rewardMint,
            remainingAccountsForKind,
        }));
    }
    return transaction;
});
exports.withCloseRewardDistributor = withCloseRewardDistributor;
const withUpdateRewardEntry = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return transaction.add(yield (0, instruction_1.updateRewardEntry)(connection, wallet, {
        stakePoolId: params.stakePoolId,
        stakeEntryId: params.stakeEntryId,
        multiplier: params.multiplier,
    }));
});
exports.withUpdateRewardEntry = withUpdateRewardEntry;
const withCloseRewardEntry = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield (0, pda_1.findRewardDistributorId)(params.stakePoolId);
    const [rewardEntryId] = yield (0, pda_1.findRewardEntryId)(rewardDistributorId, params.stakeEntryId);
    return transaction.add((0, instruction_1.closeRewardEntry)(connection, wallet, {
        rewardDistributorId: rewardDistributorId,
        rewardEntryId: rewardEntryId,
    }));
});
exports.withCloseRewardEntry = withCloseRewardEntry;
const withUpdateRewardDistributor = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield (0, pda_1.findRewardDistributorId)(params.stakePoolId);
    return transaction.add((0, instruction_1.updateRewardDistributor)(connection, wallet, {
        rewardDistributorId: rewardDistributorId,
        defaultMultiplier: params.defaultMultiplier || new anchor_1.BN(1),
        multiplierDecimals: params.multiplierDecimals || 0,
        rewardAmount: params.rewardAmount || new anchor_1.BN(0),
        rewardDurationSeconds: params.rewardDurationSeconds || new anchor_1.BN(0),
    }));
});
exports.withUpdateRewardDistributor = withUpdateRewardDistributor;
const withReclaimFunds = (transaction, connection, wallet, params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const [rewardDistributorId] = yield (0, pda_1.findRewardDistributorId)(params.stakePoolId);
    const rewardDistributorData = yield (0, common_1.tryGetAccount)(() => (0, accounts_1.getRewardDistributor)(connection, rewardDistributorId));
    if (!rewardDistributorData) {
        throw new Error("No reward distrbutor found");
    }
    const rewardDistributorTokenAccountId = yield (0, common_1.findAta)(rewardDistributorData.parsed.rewardMint, rewardDistributorData.pubkey, true);
    const authorityTokenAccountId = yield (0, common_1.findAta)(rewardDistributorData.parsed.rewardMint, wallet.publicKey, true);
    return transaction.add((0, instruction_1.reclaimFunds)(connection, wallet, {
        rewardDistributorId: rewardDistributorId,
        rewardDistributorTokenAccountId: rewardDistributorTokenAccountId,
        authorityTokenAccountId: authorityTokenAccountId,
        authority: wallet.publicKey,
        amount: params.amount,
    }));
});
exports.withReclaimFunds = withReclaimFunds;
//# sourceMappingURL=transaction.js.map