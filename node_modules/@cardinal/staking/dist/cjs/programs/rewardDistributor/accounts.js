"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllRewardEntries = exports.getRewardEntriesForRewardDistributor = exports.getRewardDistributors = exports.getRewardDistributor = exports.getRewardEntries = exports.getRewardEntry = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@project-serum/anchor");
const _1 = require(".");
const getRewardEntry = (connection, rewardEntryId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const rewardDistributorProgram = new anchor_1.Program(_1.REWARD_DISTRIBUTOR_IDL, _1.REWARD_DISTRIBUTOR_ADDRESS, provider);
    const parsed = (yield rewardDistributorProgram.account.rewardEntry.fetch(rewardEntryId));
    return {
        parsed,
        pubkey: rewardEntryId,
    };
});
exports.getRewardEntry = getRewardEntry;
const getRewardEntries = (connection, rewardEntryIds) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const rewardDistributorProgram = new anchor_1.Program(_1.REWARD_DISTRIBUTOR_IDL, _1.REWARD_DISTRIBUTOR_ADDRESS, provider);
    const stakeEntries = (yield rewardDistributorProgram.account.rewardEntry.fetchMultiple(rewardEntryIds));
    return stakeEntries.map((tm, i) => ({
        parsed: tm,
        pubkey: rewardEntryIds[i],
    }));
});
exports.getRewardEntries = getRewardEntries;
const getRewardDistributor = (connection, rewardDistributorId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const rewardDistributorProgram = new anchor_1.Program(_1.REWARD_DISTRIBUTOR_IDL, _1.REWARD_DISTRIBUTOR_ADDRESS, provider);
    const parsed = (yield rewardDistributorProgram.account.rewardDistributor.fetch(rewardDistributorId));
    return {
        parsed,
        pubkey: rewardDistributorId,
    };
});
exports.getRewardDistributor = getRewardDistributor;
const getRewardDistributors = (connection, rewardDistributorIds) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const rewardDistributorProgram = new anchor_1.Program(_1.REWARD_DISTRIBUTOR_IDL, _1.REWARD_DISTRIBUTOR_ADDRESS, provider);
    const stakeEntries = (yield rewardDistributorProgram.account.rewardDistributor.fetchMultiple(rewardDistributorIds));
    return stakeEntries.map((tm, i) => ({
        parsed: tm,
        pubkey: rewardDistributorIds[i],
    }));
});
exports.getRewardDistributors = getRewardDistributors;
const getRewardEntriesForRewardDistributor = (connection, rewardDistributorId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.REWARD_DISTRIBUTOR_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: anchor_1.utils.bytes.bs58.encode(anchor_1.BorshAccountsCoder.accountDiscriminator("rewardEntry")),
                },
            },
            {
                memcmp: {
                    offset: 41,
                    bytes: rewardDistributorId.toBase58(),
                },
            },
        ],
    });
    const rewardEntryDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.REWARD_DISTRIBUTOR_IDL);
    programAccounts.forEach((account) => {
        try {
            const rewardEntryData = coder.decode("rewardEntry", account.account.data);
            if (rewardEntryData) {
                rewardEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: rewardEntryData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return rewardEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getRewardEntriesForRewardDistributor = getRewardEntriesForRewardDistributor;
const getAllRewardEntries = (connection) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(_1.REWARD_DISTRIBUTOR_ADDRESS, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: anchor_1.utils.bytes.bs58.encode(anchor_1.BorshAccountsCoder.accountDiscriminator("rewardEntry")),
                },
            },
        ],
    });
    const rewardEntryDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(_1.REWARD_DISTRIBUTOR_IDL);
    programAccounts.forEach((account) => {
        try {
            const rewardEntryData = coder.decode("rewardEntry", account.account.data);
            if (rewardEntryData) {
                rewardEntryDatas.push(Object.assign(Object.assign({}, account), { parsed: rewardEntryData }));
            }
            // eslint-disable-next-line no-empty
        }
        catch (e) { }
    });
    return rewardEntryDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getAllRewardEntries = getAllRewardEntries;
//# sourceMappingURL=accounts.js.map