import { __awaiter } from "tslib";
import { AnchorProvider, BN, BorshAccountsCoder, Program, } from "@project-serum/anchor";
import { TIME_INVALIDATOR_ADDRESS, TIME_INVALIDATOR_IDL } from "./constants";
// TODO fix types
export const getTimeInvalidator = (connection, timeInvalidatorId) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const timeInvalidatorProgram = new Program(TIME_INVALIDATOR_IDL, TIME_INVALIDATOR_ADDRESS, provider);
    const parsed = yield timeInvalidatorProgram.account.timeInvalidator.fetch(timeInvalidatorId);
    return {
        parsed,
        pubkey: timeInvalidatorId,
    };
});
export const getTimeInvalidators = (connection, timeInvalidatorIds) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new AnchorProvider(connection, null, {});
    const timeInvalidatorProgram = new Program(TIME_INVALIDATOR_IDL, TIME_INVALIDATOR_ADDRESS, provider);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    let timeInvalidators = [];
    try {
        timeInvalidators =
            yield timeInvalidatorProgram.account.timeInvalidator.fetchMultiple(timeInvalidatorIds);
    }
    catch (e) {
        console.log(e);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return timeInvalidators.map((tm, i) => ({
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        parsed: tm,
        pubkey: timeInvalidatorIds[i],
    }));
});
export const getExpiredTimeInvalidators = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(TIME_INVALIDATOR_ADDRESS);
    const expiredTimeInvalidators = [];
    const coder = new BorshAccountsCoder(TIME_INVALIDATOR_IDL);
    programAccounts.forEach((account) => {
        var _a;
        try {
            const timeInvalidatorData = coder.decode("timeInvalidator", account.account.data);
            if ((_a = timeInvalidatorData.expiration) === null || _a === void 0 ? void 0 : _a.lte(new BN(Date.now() / 1000))) {
                expiredTimeInvalidators.push(Object.assign(Object.assign({}, account), { parsed: timeInvalidatorData }));
            }
        }
        catch (e) {
            console.log(`Failed to decode time invalidator data`);
        }
    });
    return expiredTimeInvalidators;
});
export const getAllTimeInvalidators = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(TIME_INVALIDATOR_ADDRESS);
    const expiredTimeInvalidators = [];
    const coder = new BorshAccountsCoder(TIME_INVALIDATOR_IDL);
    programAccounts.forEach((account) => {
        try {
            const timeInvalidatorData = coder.decode("timeInvalidator", account.account.data);
            expiredTimeInvalidators.push(Object.assign(Object.assign({}, account), { parsed: timeInvalidatorData }));
        }
        catch (e) {
            console.log(`Failed to decode time invalidator data`);
        }
    });
    return expiredTimeInvalidators;
});
//# sourceMappingURL=accounts.js.map