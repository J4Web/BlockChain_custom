import { __awaiter } from "tslib";
import { Edition, MetadataProgram, } from "@metaplex-foundation/mpl-token-metadata";
import { Token, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { Keypair } from "@solana/web3.js";
import { findAta, withFindOrInitAssociatedTokenAccount } from "../..";
import { InvalidationType, PAYMENT_MANAGER_KEY, TokenManagerKind, TokenManagerState, } from ".";
import { findMintManagerId } from "./pda";
export const getRemainingAccountsForKind = (mintId, tokenManagerKind) => __awaiter(void 0, void 0, void 0, function* () {
    if (tokenManagerKind === TokenManagerKind.Managed) {
        const [mintManagerId] = yield findMintManagerId(mintId);
        return [
            {
                pubkey: mintManagerId,
                isSigner: false,
                isWritable: true,
            },
        ];
    }
    else if (tokenManagerKind === TokenManagerKind.Edition) {
        const editionId = yield Edition.getPDA(mintId);
        return [
            {
                pubkey: editionId,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: MetadataProgram.PUBKEY,
                isSigner: false,
                isWritable: false,
            },
        ];
    }
    else {
        return [];
    }
});
export const withRemainingAccountsForPayment = (transaction, connection, wallet, paymentMint, issuerId, receiptMint, allowOwnerOffCurve = true) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (receiptMint) {
        const receiptMintLargestAccount = yield connection.getTokenLargestAccounts(receiptMint);
        // get holder of receipt mint
        const receiptTokenAccountId = (_a = receiptMintLargestAccount.value[0]) === null || _a === void 0 ? void 0 : _a.address;
        if (!receiptTokenAccountId)
            throw new Error("No token accounts found");
        const receiptMintToken = new Token(connection, receiptMint, TOKEN_PROGRAM_ID, Keypair.generate());
        const receiptTokenAccount = yield receiptMintToken.getAccountInfo(receiptTokenAccountId);
        // get ATA for this mint of receipt mint holder
        const [returnTokenAccountId, paymentManagerTokenAccountId] = yield Promise.all([
            receiptTokenAccount.owner.equals(wallet.publicKey)
                ? yield findAta(paymentMint, receiptTokenAccount.owner, allowOwnerOffCurve)
                : yield withFindOrInitAssociatedTokenAccount(transaction, connection, paymentMint, receiptTokenAccount.owner, wallet.publicKey, allowOwnerOffCurve),
            yield withFindOrInitAssociatedTokenAccount(transaction, connection, paymentMint, PAYMENT_MANAGER_KEY, wallet.publicKey, true),
        ]);
        return [
            returnTokenAccountId,
            paymentManagerTokenAccountId,
            [
                {
                    pubkey: receiptTokenAccountId,
                    isSigner: false,
                    isWritable: true,
                },
            ],
        ];
    }
    else {
        const [issuerTokenAccountId, paymentManagerTokenAccountId] = yield Promise.all([
            issuerId.equals(wallet.publicKey)
                ? yield findAta(paymentMint, issuerId, allowOwnerOffCurve)
                : yield withFindOrInitAssociatedTokenAccount(transaction, connection, paymentMint, issuerId, wallet.publicKey, allowOwnerOffCurve),
            yield withFindOrInitAssociatedTokenAccount(transaction, connection, paymentMint, PAYMENT_MANAGER_KEY, wallet.publicKey, true),
        ]);
        return [issuerTokenAccountId, paymentManagerTokenAccountId, []];
    }
});
export const withRemainingAccountsForReturn = (transaction, connection, wallet, tokenManagerData, allowOwnerOffCurve = true) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const { issuer, mint, invalidationType, receiptMint, state } = tokenManagerData.parsed;
    if (invalidationType === InvalidationType.Return ||
        state === TokenManagerState.Issued) {
        if (receiptMint) {
            const receiptMintLargestAccount = yield connection.getTokenLargestAccounts(receiptMint);
            // get holder of receipt mint
            const receiptTokenAccountId = (_b = receiptMintLargestAccount.value[0]) === null || _b === void 0 ? void 0 : _b.address;
            if (!receiptTokenAccountId)
                throw new Error("No token accounts found");
            const receiptMintToken = new Token(connection, receiptMint, TOKEN_PROGRAM_ID, Keypair.generate());
            const receiptTokenAccount = yield receiptMintToken.getAccountInfo(receiptTokenAccountId);
            // get ATA for this mint of receipt mint holder
            const returnTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, mint, receiptTokenAccount.owner, wallet.publicKey, allowOwnerOffCurve);
            return [
                {
                    pubkey: returnTokenAccountId,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: receiptTokenAccountId,
                    isSigner: false,
                    isWritable: true,
                },
            ];
        }
        else {
            const issuerTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, mint, issuer, wallet.publicKey, allowOwnerOffCurve);
            return [
                {
                    pubkey: issuerTokenAccountId,
                    isSigner: false,
                    isWritable: true,
                },
            ];
        }
    }
    else {
        return [];
    }
});
//# sourceMappingURL=utils.js.map