import { __awaiter } from "tslib";
import { BN } from "@project-serum/anchor";
import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID, } from "@solana/spl-token";
import { Keypair } from "@solana/web3.js";
import { findAta } from ".";
import { claimApprover, timeInvalidator, tokenManager, useInvalidator, } from "./programs";
import { InvalidationType, TokenManagerKind } from "./programs/tokenManager";
import { tokenManagerAddressFromMint } from "./programs/tokenManager/pda";
import { withRemainingAccountsForPayment, withRemainingAccountsForReturn, } from "./programs/tokenManager/utils";
import { tryGetAccount, withFindOrInitAssociatedTokenAccount } from "./utils";
/**
 * Main method for issuing any managed token
 * Allows for optional payment, optional usages or expiration and includes a otp for private links
 * @param connection
 * @param wallet
 * @param parameters
 * @returns Transaction, public key for the created token manager and a otp if necessary for private links
 */
export const withIssueToken = (transaction, connection, wallet, { claimPayment, timeInvalidation, useInvalidation, mint, amount = new BN(1), issuerTokenAccountId, kind = TokenManagerKind.Managed, invalidationType = InvalidationType.Return, visibility = "public", receiptOptions = undefined, customInvalidators = undefined, }) => __awaiter(void 0, void 0, void 0, function* () {
    // init token manager
    const numInvalidator = (customInvalidators ? customInvalidators.length : 0) +
        (useInvalidation && timeInvalidation
            ? 2
            : useInvalidation || timeInvalidation
                ? 1
                : 0);
    const [tokenManagerIx, tokenManagerId] = yield tokenManager.instruction.init(connection, wallet, mint, issuerTokenAccountId, amount, kind, invalidationType, numInvalidator);
    transaction.add(tokenManagerIx);
    //////////////////////////////
    /////// claim approver ///////
    //////////////////////////////
    let otp;
    if (claimPayment) {
        if (visibility === "private") {
            throw new Error("Private links do not currently support payment");
        }
        const [paidClaimApproverIx, paidClaimApproverId] = yield claimApprover.instruction.init(connection, wallet, tokenManagerId, claimPayment);
        transaction.add(paidClaimApproverIx);
        transaction.add(tokenManager.instruction.setClaimApprover(connection, wallet, tokenManagerId, paidClaimApproverId));
    }
    else if (visibility === "private") {
        otp = Keypair.generate();
        transaction.add(tokenManager.instruction.setClaimApprover(connection, wallet, tokenManagerId, otp.publicKey));
    }
    //////////////////////////////
    /////// time invalidator /////
    //////////////////////////////
    if (timeInvalidation) {
        const [timeInvalidatorIx, timeInvalidatorId] = yield timeInvalidator.instruction.init(connection, wallet, tokenManagerId, timeInvalidation);
        transaction.add(timeInvalidatorIx);
        transaction.add(tokenManager.instruction.addInvalidator(connection, wallet, tokenManagerId, timeInvalidatorId));
    }
    else {
        const [timeInvalidatorId] = yield timeInvalidator.pda.findTimeInvalidatorAddress(tokenManagerId);
        const timeInvalidatorData = yield tryGetAccount(() => timeInvalidator.accounts.getTimeInvalidator(connection, timeInvalidatorId));
        if (timeInvalidatorData) {
            transaction.add(timeInvalidator.instruction.close(connection, wallet, timeInvalidatorId, tokenManagerId, timeInvalidatorData.parsed.collector));
        }
    }
    //////////////////////////////
    /////////// usages ///////////
    //////////////////////////////
    if (useInvalidation) {
        const [useInvalidatorIx, useInvalidatorId] = yield useInvalidator.instruction.init(connection, wallet, tokenManagerId, useInvalidation);
        transaction.add(useInvalidatorIx);
        transaction.add(tokenManager.instruction.addInvalidator(connection, wallet, tokenManagerId, useInvalidatorId));
    }
    else {
        const [useInvalidatorId] = yield useInvalidator.pda.findUseInvalidatorAddress(tokenManagerId);
        const useInvalidatorData = yield tryGetAccount(() => useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId));
        if (useInvalidatorData) {
            transaction.add(useInvalidator.instruction.close(connection, wallet, useInvalidatorId, tokenManagerId, useInvalidatorData.parsed.collector));
        }
    }
    /////////////////////////////////////////
    //////////// custom invalidators ////////
    /////////////////////////////////////////
    if (customInvalidators) {
        for (const invalidator of customInvalidators) {
            transaction.add(tokenManager.instruction.addInvalidator(connection, wallet, tokenManagerId, invalidator));
        }
    }
    if (kind === TokenManagerKind.Managed) {
        const [mintManagerIx, mintManagerId] = yield tokenManager.instruction.creatMintManager(connection, wallet, mint);
        const mintManagerData = yield tryGetAccount(() => tokenManager.accounts.getMintManager(connection, mintManagerId));
        if (!mintManagerData) {
            transaction.add(mintManagerIx);
        }
    }
    // issuer
    const tokenManagerTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, mint, tokenManagerId, wallet.publicKey, true);
    transaction.add(tokenManager.instruction.issue(connection, wallet, tokenManagerId, tokenManagerTokenAccountId, issuerTokenAccountId));
    //////////////////////////////
    //////////// index ///////////
    //////////////////////////////
    if (receiptOptions) {
        const { receiptMintKeypair } = receiptOptions;
        transaction.add(yield tokenManager.instruction.claimReceiptMint(connection, wallet, "receipt", tokenManagerId, receiptMintKeypair.publicKey));
    }
    return [transaction, tokenManagerId, otp];
});
/**
 * Add claim instructions to a transaction
 * @param transaction
 * @param connection
 * @param wallet
 * @param tokenManagerId
 * @param otpKeypair
 * @returns Transaction with relevent claim instructions added
 */
export const withClaimToken = (transaction, connection, wallet, tokenManagerId, additionalOptions) => __awaiter(void 0, void 0, void 0, function* () {
    const [tokenManagerData, claimApproverData] = yield Promise.all([
        tokenManager.accounts.getTokenManager(connection, tokenManagerId),
        tryGetAccount(() => claimApprover.accounts.getClaimApprover(connection, tokenManagerId)),
    ]);
    let claimReceiptId;
    // pay claim approver
    if (claimApproverData &&
        tokenManagerData.parsed.claimApprover &&
        tokenManagerData.parsed.claimApprover.toString() ===
            claimApproverData.pubkey.toString()) {
        const payerTokenAccountId = yield findAta(claimApproverData.parsed.paymentMint, wallet.publicKey);
        [claimReceiptId] = yield tokenManager.pda.findClaimReceiptId(tokenManagerId, wallet.publicKey);
        const paymentAccounts = yield withRemainingAccountsForPayment(transaction, connection, wallet, claimApproverData.parsed.paymentMint, tokenManagerData.parsed.issuer, tokenManagerData.parsed.receiptMint);
        transaction.add(yield claimApprover.instruction.pay(connection, wallet, tokenManagerId, payerTokenAccountId, paymentAccounts));
    }
    else if (tokenManagerData.parsed.claimApprover) {
        if (!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.otpKeypair) ||
            (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.otpKeypair.publicKey.toString()) !==
                tokenManagerData.parsed.claimApprover.toString()) {
            throw new Error("Invalid OTP");
        }
        // approve claim request
        const [createClaimReceiptIx, claimReceipt] = yield tokenManager.instruction.createClaimReceipt(connection, wallet, tokenManagerId, additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.otpKeypair.publicKey);
        transaction.add(createClaimReceiptIx);
        claimReceiptId = claimReceipt;
    }
    const tokenManagerTokenAccountId = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenManagerData.parsed.mint, tokenManagerId, true);
    const recipientTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, tokenManagerData.parsed.mint, wallet.publicKey, wallet.publicKey);
    // claim
    transaction.add(yield tokenManager.instruction.claim(connection, wallet, tokenManagerId, tokenManagerData.parsed.kind, tokenManagerData.parsed.mint, tokenManagerTokenAccountId, recipientTokenAccountId, claimReceiptId));
    return transaction;
});
export const withUnissueToken = (transaction, connection, wallet, mintId) => __awaiter(void 0, void 0, void 0, function* () {
    const tokenManagerId = yield tokenManagerAddressFromMint(connection, mintId);
    const tokenManagerTokenAccountId = yield findAta(mintId, tokenManagerId, true);
    const issuerTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, mintId, wallet.publicKey, wallet.publicKey);
    return transaction.add(tokenManager.instruction.unissue(connection, wallet, tokenManagerId, tokenManagerTokenAccountId, issuerTokenAccountId));
});
export const withInvalidate = (transaction, connection, wallet, mintId) => __awaiter(void 0, void 0, void 0, function* () {
    const tokenManagerId = yield tokenManagerAddressFromMint(connection, mintId);
    const [[useInvalidatorId], [timeInvalidatorId]] = yield Promise.all([
        useInvalidator.pda.findUseInvalidatorAddress(tokenManagerId),
        timeInvalidator.pda.findTimeInvalidatorAddress(tokenManagerId),
    ]);
    const [useInvalidatorData, timeInvalidatorData, tokenManagerData] = yield Promise.all([
        tryGetAccount(() => useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId)),
        tryGetAccount(() => timeInvalidator.accounts.getTimeInvalidator(connection, timeInvalidatorId)),
        tryGetAccount(() => tokenManager.accounts.getTokenManager(connection, tokenManagerId)),
    ]);
    if (!tokenManagerData)
        return transaction;
    const tokenManagerTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, mintId, tokenManagerId, wallet.publicKey, true);
    const remainingAccountsForReturn = yield withRemainingAccountsForReturn(transaction, connection, wallet, tokenManagerData);
    if (useInvalidatorData &&
        useInvalidatorData.parsed.totalUsages &&
        useInvalidatorData.parsed.usages.gte(useInvalidatorData.parsed.totalUsages)) {
        transaction.add(yield useInvalidator.instruction.invalidate(connection, wallet, mintId, tokenManagerId, tokenManagerData.parsed.kind, tokenManagerData.parsed.state, tokenManagerTokenAccountId, tokenManagerData === null || tokenManagerData === void 0 ? void 0 : tokenManagerData.parsed.recipientTokenAccount, remainingAccountsForReturn));
        transaction.add(useInvalidator.instruction.close(connection, wallet, useInvalidatorId, tokenManagerId, useInvalidatorData.parsed.collector));
    }
    else if (timeInvalidatorData &&
        ((timeInvalidatorData.parsed.expiration &&
            timeInvalidatorData.parsed.expiration.lte(new BN(Date.now() / 1000))) ||
            (timeInvalidatorData.parsed.durationSeconds &&
                tokenManagerData.parsed.stateChangedAt
                    .add(timeInvalidatorData.parsed.durationSeconds)
                    .lte(new BN(Date.now() / 1000))))) {
        transaction.add(yield timeInvalidator.instruction.invalidate(connection, wallet, mintId, tokenManagerId, tokenManagerData.parsed.kind, tokenManagerData.parsed.state, tokenManagerTokenAccountId, tokenManagerData === null || tokenManagerData === void 0 ? void 0 : tokenManagerData.parsed.recipientTokenAccount, remainingAccountsForReturn));
        transaction.add(timeInvalidator.instruction.close(connection, wallet, timeInvalidatorData.pubkey, timeInvalidatorData.parsed.tokenManager, timeInvalidatorData.parsed.collector));
    }
    else if (tokenManagerData.parsed.invalidators.some((inv) => inv.equals(wallet.publicKey)) ||
        tokenManagerData.parsed.invalidationType === InvalidationType.Return ||
        tokenManagerData.parsed.invalidationType === InvalidationType.Reissue) {
        transaction.add(yield tokenManager.instruction.invalidate(connection, wallet, mintId, tokenManagerId, tokenManagerData.parsed.kind, tokenManagerData.parsed.state, tokenManagerTokenAccountId, tokenManagerData === null || tokenManagerData === void 0 ? void 0 : tokenManagerData.parsed.recipientTokenAccount, remainingAccountsForReturn));
    }
    return transaction;
});
export const withUse = (transaction, connection, wallet, mintId, usages, collector) => __awaiter(void 0, void 0, void 0, function* () {
    const tokenManagerId = yield tokenManagerAddressFromMint(connection, mintId);
    const [useInvalidatorId] = yield useInvalidator.pda.findUseInvalidatorAddress(tokenManagerId);
    const [useInvalidatorData, tokenManagerData] = yield Promise.all([
        tryGetAccount(() => useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId)),
        tryGetAccount(() => tokenManager.accounts.getTokenManager(connection, tokenManagerId)),
    ]);
    if (!useInvalidatorData) {
        // init
        const [InitTx] = yield useInvalidator.instruction.init(connection, wallet, tokenManagerId, { collector: collector });
        transaction.add(InitTx);
    }
    if (!(tokenManagerData === null || tokenManagerData === void 0 ? void 0 : tokenManagerData.parsed.recipientTokenAccount))
        throw new Error("Token manager has not been claimed");
    // use
    transaction.add(yield useInvalidator.instruction.incrementUsages(connection, wallet, tokenManagerId, tokenManagerData === null || tokenManagerData === void 0 ? void 0 : tokenManagerData.parsed.recipientTokenAccount, usages));
    if ((useInvalidatorData === null || useInvalidatorData === void 0 ? void 0 : useInvalidatorData.parsed.totalUsages) &&
        (useInvalidatorData === null || useInvalidatorData === void 0 ? void 0 : useInvalidatorData.parsed.usages.add(new BN(usages)).gte(useInvalidatorData === null || useInvalidatorData === void 0 ? void 0 : useInvalidatorData.parsed.totalUsages))) {
        const tokenManagerTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, mintId, tokenManagerId, wallet.publicKey, true);
        const remainingAccountsForReturn = yield withRemainingAccountsForReturn(transaction, connection, wallet, tokenManagerData);
        transaction.add(yield useInvalidator.instruction.invalidate(connection, wallet, mintId, tokenManagerId, tokenManagerData.parsed.kind, tokenManagerData.parsed.state, tokenManagerTokenAccountId, tokenManagerData === null || tokenManagerData === void 0 ? void 0 : tokenManagerData.parsed.recipientTokenAccount, remainingAccountsForReturn));
        transaction.add(useInvalidator.instruction.close(connection, wallet, useInvalidatorId, tokenManagerId, useInvalidatorData.parsed.collector));
    }
    return transaction;
});
export const withExtendExpiration = (transaction, connection, wallet, tokenManagerId, paymentAmount) => __awaiter(void 0, void 0, void 0, function* () {
    const [timeInvalidatorId] = yield timeInvalidator.pda.findTimeInvalidatorAddress(tokenManagerId);
    const [timeInvalidatorData, tokenManagerData] = yield Promise.all([
        timeInvalidator.accounts.getTimeInvalidator(connection, timeInvalidatorId),
        tokenManager.accounts.getTokenManager(connection, tokenManagerId),
    ]);
    if (timeInvalidatorData && timeInvalidatorData.parsed.extensionPaymentMint) {
        const payerTokenAccountId = yield findAta(timeInvalidatorData.parsed.extensionPaymentMint, wallet.publicKey);
        const paymentAccounts = yield withRemainingAccountsForPayment(transaction, connection, wallet, timeInvalidatorData.parsed.extensionPaymentMint, tokenManagerData.parsed.issuer, tokenManagerData.parsed.receiptMint);
        transaction.add(timeInvalidator.instruction.extendExpiration(connection, wallet, tokenManagerId, payerTokenAccountId, timeInvalidatorId, paymentAmount, paymentAccounts));
    }
    else {
        console.log("No payment mint");
    }
    return transaction;
});
export const withExtendUsages = (transaction, connection, wallet, tokenManagerId, paymentAmount) => __awaiter(void 0, void 0, void 0, function* () {
    const [useInvalidatorId] = yield useInvalidator.pda.findUseInvalidatorAddress(tokenManagerId);
    const [useInvalidatorData, tokenManagerData] = yield Promise.all([
        useInvalidator.accounts.getUseInvalidator(connection, useInvalidatorId),
        tokenManager.accounts.getTokenManager(connection, tokenManagerId),
    ]);
    if (useInvalidatorData && useInvalidatorData.parsed.extensionPaymentMint) {
        const payerTokenAccountId = yield withFindOrInitAssociatedTokenAccount(transaction, connection, useInvalidatorData.parsed.extensionPaymentMint, wallet.publicKey, wallet.publicKey);
        const paymentAccounts = yield withRemainingAccountsForPayment(transaction, connection, wallet, useInvalidatorData.parsed.extensionPaymentMint, tokenManagerData.parsed.issuer, tokenManagerData.parsed.receiptMint);
        transaction.add(useInvalidator.instruction.extendUsages(connection, wallet, tokenManagerId, payerTokenAccountId, useInvalidatorId, paymentAmount, paymentAccounts));
    }
    return transaction;
});
//# sourceMappingURL=transaction.js.map