"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.close = exports.pay = exports.init = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@project-serum/anchor");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const tokenManager_1 = require("../tokenManager");
const pda_1 = require("../tokenManager/pda");
const constants_1 = require("./constants");
const pda_2 = require("./pda");
const init = (connection, wallet, tokenManagerId, params) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const provider = new anchor_1.AnchorProvider(connection, wallet, {});
    const claimApproverProgram = new anchor_1.Program(constants_1.CLAIM_APPROVER_IDL, constants_1.CLAIM_APPROVER_ADDRESS, provider);
    const [claimApproverId, _claimApproverBump] = yield (0, pda_2.findClaimApproverAddress)(tokenManagerId);
    return [
        claimApproverProgram.instruction.init({
            paymentMint: params.paymentMint,
            paymentAmount: new anchor_1.BN(params.paymentAmount),
            collector: params.collector || tokenManager_1.CRANK_KEY,
            paymentManager: params.paymentManager || tokenManager_1.PAYMENT_MANAGER_KEY,
        }, {
            accounts: {
                tokenManager: tokenManagerId,
                claimApprover: claimApproverId,
                issuer: wallet.publicKey,
                payer: wallet.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
            },
        }),
        claimApproverId,
    ];
});
exports.init = init;
const pay = (connection, wallet, tokenManagerId, payerTokenAccountId, paymentAccounts) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const provider = new anchor_1.AnchorProvider(connection, wallet, {});
    const claimApproverProgram = new anchor_1.Program(constants_1.CLAIM_APPROVER_IDL, constants_1.CLAIM_APPROVER_ADDRESS, provider);
    const [claimReceiptId, _claimReceiptBump] = yield (0, pda_1.findClaimReceiptId)(tokenManagerId, wallet.publicKey);
    const [claimApproverId] = yield (0, pda_2.findClaimApproverAddress)(tokenManagerId);
    const [paymentTokenAccountId, paymentManagerTokenAccountId, remainingAccounts,] = paymentAccounts;
    return claimApproverProgram.instruction.pay({
        accounts: {
            tokenManager: tokenManagerId,
            paymentTokenAccount: paymentTokenAccountId,
            claimApprover: claimApproverId,
            payer: wallet.publicKey,
            payerTokenAccount: payerTokenAccountId,
            paymentManagerTokenAccount: paymentManagerTokenAccountId,
            claimReceipt: claimReceiptId,
            cardinalTokenManager: tokenManager_1.TOKEN_MANAGER_ADDRESS,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
        remainingAccounts,
    });
});
exports.pay = pay;
const close = (connection, wallet, claimApproverId, tokenManagerId, collector) => {
    const provider = new anchor_1.AnchorProvider(connection, wallet, {});
    const claimApproverProgram = new anchor_1.Program(constants_1.CLAIM_APPROVER_IDL, constants_1.CLAIM_APPROVER_ADDRESS, provider);
    return claimApproverProgram.instruction.close({
        accounts: {
            tokenManager: tokenManagerId,
            claimApprover: claimApproverId,
            collector: collector || tokenManager_1.CRANK_KEY,
            closer: wallet.publicKey,
        },
    });
};
exports.close = close;
//# sourceMappingURL=instruction.js.map