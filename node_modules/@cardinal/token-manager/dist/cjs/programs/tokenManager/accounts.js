"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenManagersForIssuer = exports.getMintCounter = exports.getMintManager = exports.getTokenManagersByState = exports.getTokenManagers = exports.getTokenManager = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@project-serum/anchor");
const constants_1 = require("./constants");
const getTokenManager = (connection, tokenManagerId) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const tokenManagerProgram = new anchor_1.Program(constants_1.TOKEN_MANAGER_IDL, constants_1.TOKEN_MANAGER_ADDRESS, provider);
    const parsed = yield tokenManagerProgram.account.tokenManager.fetch(tokenManagerId);
    return {
        parsed,
        pubkey: tokenManagerId,
    };
});
exports.getTokenManager = getTokenManager;
const getTokenManagers = (connection, tokenManagerIds) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const tokenManagerProgram = new anchor_1.Program(constants_1.TOKEN_MANAGER_IDL, constants_1.TOKEN_MANAGER_ADDRESS, provider);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    let tokenManagers = [];
    try {
        tokenManagers =
            yield tokenManagerProgram.account.tokenManager.fetchMultiple(tokenManagerIds);
    }
    catch (e) {
        console.log(e);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return tokenManagers.map((tm, i) => ({
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        parsed: tm,
        pubkey: tokenManagerIds[i],
    }));
});
exports.getTokenManagers = getTokenManagers;
const getTokenManagersByState = (connection, state) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(constants_1.TOKEN_MANAGER_ADDRESS, {
        filters: state
            ? [
                {
                    memcmp: {
                        offset: 92,
                        bytes: anchor_1.utils.bytes.bs58.encode(new anchor_1.BN(state).toArrayLike(Buffer, "le", 1)),
                    },
                },
            ]
            : [],
    });
    const tokenManagerDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(constants_1.TOKEN_MANAGER_IDL);
    programAccounts.forEach((account) => {
        try {
            const tokenManagerData = coder.decode("tokenManager", account.account.data);
            if (tokenManagerData) {
                tokenManagerDatas.push(Object.assign(Object.assign({}, account), { parsed: tokenManagerData }));
            }
        }
        catch (e) {
            console.log(`Failed to decode token manager data`);
        }
    });
    return tokenManagerDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getTokenManagersByState = getTokenManagersByState;
const getMintManager = (connection, mintManagerId) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const tokenManagerProgram = new anchor_1.Program(constants_1.TOKEN_MANAGER_IDL, constants_1.TOKEN_MANAGER_ADDRESS, provider);
    const parsed = yield tokenManagerProgram.account.mintManager.fetch(mintManagerId);
    return {
        parsed,
        pubkey: mintManagerId,
    };
});
exports.getMintManager = getMintManager;
const getMintCounter = (connection, mintCounterId) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const tokenManagerProgram = new anchor_1.Program(constants_1.TOKEN_MANAGER_IDL, constants_1.TOKEN_MANAGER_ADDRESS, provider);
    const parsed = yield tokenManagerProgram.account.mintCounter.fetch(mintCounterId);
    return {
        parsed,
        pubkey: mintCounterId,
    };
});
exports.getMintCounter = getMintCounter;
const getTokenManagersForIssuer = (connection, issuerId) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(constants_1.TOKEN_MANAGER_ADDRESS, {
        filters: [{ memcmp: { offset: 19, bytes: issuerId.toBase58() } }],
    });
    const tokenManagerDatas = [];
    const coder = new anchor_1.BorshAccountsCoder(constants_1.TOKEN_MANAGER_IDL);
    programAccounts.forEach((account) => {
        try {
            const tokenManagerData = coder.decode("tokenManager", account.account.data);
            if (tokenManagerData) {
                tokenManagerDatas.push(Object.assign(Object.assign({}, account), { parsed: tokenManagerData }));
            }
        }
        catch (e) {
            console.log(`Failed to decode token manager data`);
        }
    });
    return tokenManagerDatas.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
});
exports.getTokenManagersForIssuer = getTokenManagersForIssuer;
//# sourceMappingURL=accounts.js.map