{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../src/programs/tokenManager/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Edition,\n  MetadataProgram,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport type { Wallet } from \"@saberhq/solana-contrib\";\nimport { Token, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type {\n  AccountMeta,\n  Connection,\n  PublicKey,\n  Transaction,\n} from \"@solana/web3.js\";\nimport { Keypair } from \"@solana/web3.js\";\n\nimport type { AccountData } from \"../..\";\nimport { findAta, withFindOrInitAssociatedTokenAccount } from \"../..\";\nimport type { TokenManagerData } from \".\";\nimport {\n  InvalidationType,\n  PAYMENT_MANAGER_KEY,\n  TokenManagerKind,\n  TokenManagerState,\n} from \".\";\nimport { findMintManagerId } from \"./pda\";\n\nexport const getRemainingAccountsForKind = async (\n  mintId: PublicKey,\n  tokenManagerKind: TokenManagerKind\n): Promise<AccountMeta[]> => {\n  if (tokenManagerKind === TokenManagerKind.Managed) {\n    const [mintManagerId] = await findMintManagerId(mintId);\n    return [\n      {\n        pubkey: mintManagerId,\n        isSigner: false,\n        isWritable: true,\n      },\n    ];\n  } else if (tokenManagerKind === TokenManagerKind.Edition) {\n    const editionId = await Edition.getPDA(mintId);\n    return [\n      {\n        pubkey: editionId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: MetadataProgram.PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n  } else {\n    return [];\n  }\n};\n\nexport const withRemainingAccountsForPayment = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  paymentMint: PublicKey,\n  issuerId: PublicKey,\n  receiptMint?: PublicKey | null,\n  allowOwnerOffCurve = true\n): Promise<[PublicKey, PublicKey, AccountMeta[]]> => {\n  if (receiptMint) {\n    const receiptMintLargestAccount = await connection.getTokenLargestAccounts(\n      receiptMint\n    );\n    // get holder of receipt mint\n    const receiptTokenAccountId = receiptMintLargestAccount.value[0]?.address;\n    if (!receiptTokenAccountId) throw new Error(\"No token accounts found\");\n    const receiptMintToken = new Token(\n      connection,\n      receiptMint,\n      TOKEN_PROGRAM_ID,\n      Keypair.generate()\n    );\n    const receiptTokenAccount = await receiptMintToken.getAccountInfo(\n      receiptTokenAccountId\n    );\n\n    // get ATA for this mint of receipt mint holder\n    const [returnTokenAccountId, paymentManagerTokenAccountId] =\n      await Promise.all([\n        receiptTokenAccount.owner.equals(wallet.publicKey)\n          ? await findAta(\n              paymentMint,\n              receiptTokenAccount.owner,\n              allowOwnerOffCurve\n            )\n          : await withFindOrInitAssociatedTokenAccount(\n              transaction,\n              connection,\n              paymentMint,\n              receiptTokenAccount.owner,\n              wallet.publicKey,\n              allowOwnerOffCurve\n            ),\n        await withFindOrInitAssociatedTokenAccount(\n          transaction,\n          connection,\n          paymentMint,\n          PAYMENT_MANAGER_KEY,\n          wallet.publicKey,\n          true\n        ),\n      ]);\n    return [\n      returnTokenAccountId,\n      paymentManagerTokenAccountId,\n      [\n        {\n          pubkey: receiptTokenAccountId,\n          isSigner: false,\n          isWritable: true,\n        },\n      ],\n    ];\n  } else {\n    const [issuerTokenAccountId, paymentManagerTokenAccountId] =\n      await Promise.all([\n        issuerId.equals(wallet.publicKey)\n          ? await findAta(paymentMint, issuerId, allowOwnerOffCurve)\n          : await withFindOrInitAssociatedTokenAccount(\n              transaction,\n              connection,\n              paymentMint,\n              issuerId,\n              wallet.publicKey,\n              allowOwnerOffCurve\n            ),\n        await withFindOrInitAssociatedTokenAccount(\n          transaction,\n          connection,\n          paymentMint,\n          PAYMENT_MANAGER_KEY,\n          wallet.publicKey,\n          true\n        ),\n      ]);\n    return [issuerTokenAccountId, paymentManagerTokenAccountId, []];\n  }\n};\n\nexport const withRemainingAccountsForReturn = async (\n  transaction: Transaction,\n  connection: Connection,\n  wallet: Wallet,\n  tokenManagerData: AccountData<TokenManagerData>,\n  allowOwnerOffCurve = true\n): Promise<AccountMeta[]> => {\n  const { issuer, mint, invalidationType, receiptMint, state } =\n    tokenManagerData.parsed;\n  if (\n    invalidationType === InvalidationType.Return ||\n    state === TokenManagerState.Issued\n  ) {\n    if (receiptMint) {\n      const receiptMintLargestAccount =\n        await connection.getTokenLargestAccounts(receiptMint);\n\n      // get holder of receipt mint\n      const receiptTokenAccountId = receiptMintLargestAccount.value[0]?.address;\n      if (!receiptTokenAccountId) throw new Error(\"No token accounts found\");\n      const receiptMintToken = new Token(\n        connection,\n        receiptMint,\n        TOKEN_PROGRAM_ID,\n        Keypair.generate()\n      );\n      const receiptTokenAccount = await receiptMintToken.getAccountInfo(\n        receiptTokenAccountId\n      );\n\n      // get ATA for this mint of receipt mint holder\n      const returnTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n        transaction,\n        connection,\n        mint,\n        receiptTokenAccount.owner,\n        wallet.publicKey,\n        allowOwnerOffCurve\n      );\n      return [\n        {\n          pubkey: returnTokenAccountId,\n          isSigner: false,\n          isWritable: true,\n        },\n        {\n          pubkey: receiptTokenAccountId,\n          isSigner: false,\n          isWritable: true,\n        },\n      ];\n    } else {\n      const issuerTokenAccountId = await withFindOrInitAssociatedTokenAccount(\n        transaction,\n        connection,\n        mint,\n        issuer,\n        wallet.publicKey,\n        allowOwnerOffCurve\n      );\n      return [\n        {\n          pubkey: issuerTokenAccountId,\n          isSigner: false,\n          isWritable: true,\n        },\n      ];\n    }\n  } else {\n    return [];\n  }\n};\n"]}