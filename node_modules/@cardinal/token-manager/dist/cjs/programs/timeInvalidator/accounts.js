"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllTimeInvalidators = exports.getExpiredTimeInvalidators = exports.getTimeInvalidators = exports.getTimeInvalidator = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@project-serum/anchor");
const constants_1 = require("./constants");
// TODO fix types
const getTimeInvalidator = (connection, timeInvalidatorId) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const timeInvalidatorProgram = new anchor_1.Program(constants_1.TIME_INVALIDATOR_IDL, constants_1.TIME_INVALIDATOR_ADDRESS, provider);
    const parsed = yield timeInvalidatorProgram.account.timeInvalidator.fetch(timeInvalidatorId);
    return {
        parsed,
        pubkey: timeInvalidatorId,
    };
});
exports.getTimeInvalidator = getTimeInvalidator;
const getTimeInvalidators = (connection, timeInvalidatorIds) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const provider = new anchor_1.AnchorProvider(connection, null, {});
    const timeInvalidatorProgram = new anchor_1.Program(constants_1.TIME_INVALIDATOR_IDL, constants_1.TIME_INVALIDATOR_ADDRESS, provider);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    let timeInvalidators = [];
    try {
        timeInvalidators =
            yield timeInvalidatorProgram.account.timeInvalidator.fetchMultiple(timeInvalidatorIds);
    }
    catch (e) {
        console.log(e);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return timeInvalidators.map((tm, i) => ({
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        parsed: tm,
        pubkey: timeInvalidatorIds[i],
    }));
});
exports.getTimeInvalidators = getTimeInvalidators;
const getExpiredTimeInvalidators = (connection) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(constants_1.TIME_INVALIDATOR_ADDRESS);
    const expiredTimeInvalidators = [];
    const coder = new anchor_1.BorshAccountsCoder(constants_1.TIME_INVALIDATOR_IDL);
    programAccounts.forEach((account) => {
        var _a;
        try {
            const timeInvalidatorData = coder.decode("timeInvalidator", account.account.data);
            if ((_a = timeInvalidatorData.expiration) === null || _a === void 0 ? void 0 : _a.lte(new anchor_1.BN(Date.now() / 1000))) {
                expiredTimeInvalidators.push(Object.assign(Object.assign({}, account), { parsed: timeInvalidatorData }));
            }
        }
        catch (e) {
            console.log(`Failed to decode time invalidator data`);
        }
    });
    return expiredTimeInvalidators;
});
exports.getExpiredTimeInvalidators = getExpiredTimeInvalidators;
const getAllTimeInvalidators = (connection) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const programAccounts = yield connection.getProgramAccounts(constants_1.TIME_INVALIDATOR_ADDRESS);
    const expiredTimeInvalidators = [];
    const coder = new anchor_1.BorshAccountsCoder(constants_1.TIME_INVALIDATOR_IDL);
    programAccounts.forEach((account) => {
        try {
            const timeInvalidatorData = coder.decode("timeInvalidator", account.account.data);
            expiredTimeInvalidators.push(Object.assign(Object.assign({}, account), { parsed: timeInvalidatorData }));
        }
        catch (e) {
            console.log(`Failed to decode time invalidator data`);
        }
    });
    return expiredTimeInvalidators;
});
exports.getAllTimeInvalidators = getAllTimeInvalidators;
//# sourceMappingURL=accounts.js.map